import*as e from"three";import{Ray as t,Plane as n,MathUtils as r,EventDispatcher as s,Vector3 as o,MOUSE as i,TOUCH as a,Quaternion as c,Spherical as l,Vector2 as h}from"three";class d{static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerColor:4,BytesPerRotation:16,ScaleRange:1},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerColor:4,BytesPerRotation:8,ScaleRange:32767}};static CovarianceSizeFloats=6;static CovarianceSizeBytes=24;static HeaderSizeBytes=1024;constructor(e){this.headerBufferData=new ArrayBuffer(d.HeaderSizeBytes),this.headerArrayUint8=new Uint8Array(this.headerBufferData),this.headerArrayUint32=new Uint32Array(this.headerBufferData),this.headerArrayFloat32=new Float32Array(this.headerBufferData),this.headerArrayUint8.set(new Uint8Array(e,0,d.HeaderSizeBytes)),this.versionMajor=this.headerArrayUint8[0],this.versionMinor=this.headerArrayUint8[1],this.headerExtraK=this.headerArrayUint8[2],this.compressionLevel=this.headerArrayUint8[3],this.splatCount=this.headerArrayUint32[1],this.bucketSize=this.headerArrayUint32[2],this.bucketCount=this.headerArrayUint32[3],this.bucketBlockSize=this.headerArrayFloat32[4],this.halfBucketBlockSize=this.bucketBlockSize/2,this.bytesPerBucket=this.headerArrayUint32[5],this.compressionScaleRange=this.headerArrayUint32[6]||d.CompressionLevels[this.compressionLevel].ScaleRange,this.compressionScaleFactor=this.halfBucketBlockSize/this.compressionScaleRange;const t=e.byteLength-d.HeaderSizeBytes;this.splatBufferData=new ArrayBuffer(t),new Uint8Array(this.splatBufferData).set(new Uint8Array(e,d.HeaderSizeBytes,t)),this.bytesPerCenter=d.CompressionLevels[this.compressionLevel].BytesPerCenter,this.bytesPerScale=d.CompressionLevels[this.compressionLevel].BytesPerScale,this.bytesPerColor=d.CompressionLevels[this.compressionLevel].BytesPerColor,this.bytesPerRotation=d.CompressionLevels[this.compressionLevel].BytesPerRotation,this.bytesPerSplat=this.bytesPerCenter+this.bytesPerScale+this.bytesPerColor+this.bytesPerRotation,this.linkBufferArrays()}linkBufferArrays(){let e=0===this.compressionLevel?Float32Array:Uint16Array;this.centerArray=new e(this.splatBufferData,0,this.splatCount*d.CenterComponentCount),this.scaleArray=new e(this.splatBufferData,this.bytesPerCenter*this.splatCount,this.splatCount*d.ScaleComponentCount),this.colorArray=new Uint8Array(this.splatBufferData,(this.bytesPerCenter+this.bytesPerScale)*this.splatCount,this.splatCount*d.ColorComponentCount),this.rotationArray=new e(this.splatBufferData,(this.bytesPerCenter+this.bytesPerScale+this.bytesPerColor)*this.splatCount,this.splatCount*d.RotationComponentCount),this.bucketsBase=this.splatCount*this.bytesPerSplat}fbf(t){return 0===this.compressionLevel?t:e.DataUtils.fromHalfFloat(t)}getHeaderBufferData(){return this.headerBufferData}getSplatBufferData(){return this.splatBufferData}getSplatCount(){return this.splatCount}getSplatCenter(e,t,n){let r=[0,0,0];const s=e*d.CenterComponentCount;if(this.compressionLevel>0){const n=this.compressionScaleFactor,o=this.compressionScaleRange,i=Math.floor(e/this.bucketSize);r=new Float32Array(this.splatBufferData,this.bucketsBase+i*this.bytesPerBucket,3),t.x=(this.centerArray[s]-o)*n+r[0],t.y=(this.centerArray[s+1]-o)*n+r[1],t.z=(this.centerArray[s+2]-o)*n+r[2]}else t.x=this.centerArray[s],t.y=this.centerArray[s+1],t.z=this.centerArray[s+2];n&&t.applyMatrix4(n)}getSplatScaleAndRotation=function(){const t=new e.Matrix4,n=new e.Matrix4,r=new e.Matrix4,s=new e.Vector3;return function(e,o,i,a){const c=e*d.ScaleComponentCount;o.set(this.fbf(this.scaleArray[c]),this.fbf(this.scaleArray[c+1]),this.fbf(this.scaleArray[c+2]));const l=e*d.RotationComponentCount;i.set(this.fbf(this.rotationArray[l+1]),this.fbf(this.rotationArray[l+2]),this.fbf(this.rotationArray[l+3]),this.fbf(this.rotationArray[l])),a&&(t.makeScale(o.x,o.y,o.z),n.makeRotationFromQuaternion(i),r.copy(t).multiply(n).multiply(a),r.decompose(s,i,o))}}();getSplatColor(e,t,n){const r=e*d.ColorComponentCount;t.set(this.colorArray[r],this.colorArray[r+1],this.colorArray[r+2],this.colorArray[r+3])}fillSplatCenterArray(t,n,r){const s=this.splatCount;let o=[0,0,0];const i=new e.Vector3;for(let e=0;e<s;e++){const s=e*d.CenterComponentCount,a=(e+n)*d.CenterComponentCount;if(this.compressionLevel>0){const t=Math.floor(e/this.bucketSize);o=new Float32Array(this.splatBufferData,this.bucketsBase+t*this.bytesPerBucket,3);const n=this.compressionScaleFactor,r=this.compressionScaleRange;i.x=(this.centerArray[s]-r)*n+o[0],i.y=(this.centerArray[s+1]-r)*n+o[1],i.z=(this.centerArray[s+2]-r)*n+o[2]}else i.x=this.centerArray[s],i.y=this.centerArray[s+1],i.z=this.centerArray[s+2];r&&i.applyMatrix4(r),t[a]=i.x,t[a+1]=i.y,t[a+2]=i.z}}fillSplatCovarianceArray(t,n,r){const s=this.splatCount,o=new e.Vector3,i=new e.Quaternion,a=new e.Matrix3,c=new e.Matrix3,l=new e.Matrix3,h=new e.Matrix3,u=new e.Matrix3,p=new e.Matrix3,m=new e.Matrix4;for(let e=0;e<s;e++){const s=e*d.ScaleComponentCount;o.set(this.fbf(this.scaleArray[s]),this.fbf(this.scaleArray[s+1]),this.fbf(this.scaleArray[s+2])),m.makeScale(o.x,o.y,o.z),c.setFromMatrix4(m);const f=e*d.RotationComponentCount;i.set(this.fbf(this.rotationArray[f+1]),this.fbf(this.rotationArray[f+2]),this.fbf(this.rotationArray[f+3]),this.fbf(this.rotationArray[f])),m.makeRotationFromQuaternion(i),a.setFromMatrix4(m),l.copy(a).multiply(c),h.copy(l).transpose().premultiply(l);const g=d.CovarianceSizeFloats*(e+n);r&&(u.setFromMatrix4(r),p.copy(u).transpose(),h.multiply(p),h.premultiply(u)),t[g]=h.elements[0],t[g+1]=h.elements[3],t[g+2]=h.elements[6],t[g+3]=h.elements[4],t[g+4]=h.elements[7],t[g+5]=h.elements[8]}}fillSplatColorArray(e,t,n){const r=this.splatCount;for(let n=0;n<r;n++){const r=n*d.ColorComponentCount,s=(n+t)*d.ColorComponentCount;e[s]=this.colorArray[r],e[s+1]=this.colorArray[r+1],e[s+2]=this.colorArray[r+2],e[s+3]=this.colorArray[r+3]}}}class u{constructor(e,t){let n,r;this.promise=new Promise(((e,t)=>{n=e.bind(this),r=t.bind(this)}));e(((...e)=>{n(...e)}).bind(this),(e=>{r(e)}).bind(this)),this.abortHandler=t}then(e){return new u(((t,n)=>{this.promise=this.promise.then(((...n)=>{const r=e(...n);r instanceof Promise||r instanceof u?r.then(((...e)=>{t(...e)})):t(r)})).catch((e=>{n(e)}))}),this.abortHandler)}catch(e){return new u((t=>{this.promise=this.promise.then(((...e)=>{t(...e)})).catch(e)}),this.abortHandler)}abort(){this.abortHandler&&this.abortHandler()}static resolve(e){return new u((t=>{t(e)}))}static reject(e){return new u(((t,n)=>{n(e)}))}}!function(){const e=new Float32Array(1),t=new Int32Array(e.buffer)}();const p=function(){const e=new Float32Array(1),t=new Int32Array(e.buffer);return function(n){return e[0]=n,t[0]}}(),m=function(e,t){const n=new AbortController,r=n.signal;let s=!1,o=null;return new u(((n,i)=>{o=i,fetch(e,{signal:r}).then((async e=>{const r=e.body.getReader();let o=0,a=e.headers.get("Content-Length"),c=a?parseInt(a):void 0;const l=[];for(;!s;)try{const{value:e,done:s}=await r.read();if(s){t&&t(100,"100%",e);const r=new Blob(l).arrayBuffer();n(r);break}let i,a;o+=e.length,void 0!==c&&(i=o/c*100,a=`${i.toFixed(2)}%`),l.push(e),t&&t(i,a,e)}catch(e){i(e);break}}))}),(()=>{n.abort(),o("Fetch aborted"),s=!0}))},f=function(e,t,n){return Math.max(Math.min(e,n),t)},g=function(){return performance.now()/1e3},y=e=>{if(e.geometry&&(e.geometry.dispose(),e.geometry=null),e.material&&(e.material.dispose(),e.material=null),e.children)for(let t of e.children)y(t)};class A{constructor(){this.splatCount=0,this.scale_0=[],this.scale_1=[],this.scale_2=[],this.rot_0=[],this.rot_1=[],this.rot_2=[],this.rot_3=[],this.x=[],this.y=[],this.z=[],this.f_dc_0=[],this.f_dc_1=[],this.f_dc_2=[],this.opacity=[]}addSplat(e,t,n,r,s,o,i,a,c,l,h,d,u,p){this.x.push(e),this.y.push(t),this.z.push(n),this.scale_0.push(r),this.scale_1.push(s),this.scale_2.push(o),this.rot_0.push(i),this.rot_1.push(a),this.rot_2.push(c),this.rot_3.push(l),this.f_dc_0.push(h),this.f_dc_1.push(d),this.f_dc_2.push(u),this.opacity.push(p),this.splatCount++}}class x{constructor(e=0,t=1,n=5,r=256){this.compressionLevel=e,this.minimumAlpha=t,this.bucketSize=r,this.blockSize=n}static createEmptyUncompressedSplatArray(){return new A}uncompressedSplatArrayToSplatBuffer(t){const n=x.createEmptyUncompressedSplatArray();n.addSplat(0,0,0,0,0,0,1,0,0,0,0,0,0,0);for(let e=0;e<t.splatCount;e++){let r;r=t.opacity[e]?t.opacity[e]:255,r>=this.minimumAlpha&&n.addSplat(t.x[e],t.y[e],t.z[e],t.scale_0[e],t.scale_1[e],t.scale_2[e],t.rot_0[e],t.rot_1[e],t.rot_2[e],t.rot_3[e],t.f_dc_0[e],t.f_dc_1[e],t.f_dc_2[e],t.opacity[e])}const r=this.computeBucketsForUncompressedSplatArray(n),s=r.length*this.bucketSize,o=d.HeaderSizeBytes,i=new Uint8Array(new ArrayBuffer(o));i[3]=this.compressionLevel,new Uint32Array(i.buffer,4,1)[0]=s;let a=d.CompressionLevels[this.compressionLevel].BytesPerCenter,c=d.CompressionLevels[this.compressionLevel].BytesPerScale,l=d.CompressionLevels[this.compressionLevel].BytesPerColor,h=d.CompressionLevels[this.compressionLevel].BytesPerRotation;const u=new ArrayBuffer(a*s),p=new ArrayBuffer(c*s),m=new ArrayBuffer(l*s),g=new ArrayBuffer(h*s),y=this.blockSize/2,A=d.CompressionLevels[this.compressionLevel].ScaleRange,C=A/y,w=2*A+1,v=new e.Vector3,b=new e.Vector3;let S=0;for(let t=0;t<r.length;t++){const s=r[t];v.fromArray(s.center);for(let t=0;t<s.splats.length;t++){let r=s.splats[t],o=!1;if(0===r&&(o=!0),0===this.compressionLevel){const t=new Float32Array(u,S*a,3),s=new Float32Array(p,S*c,3),o=new Float32Array(g,S*h,4);if(void 0!==n.scale_0[r]){const t=new e.Quaternion(n.rot_1[r],n.rot_2[r],n.rot_3[r],n.rot_0[r]);t.normalize(),o.set([t.w,t.x,t.y,t.z]),s.set([n.scale_0[r],n.scale_1[r],n.scale_2[r]])}else s.set([.01,.01,.01]),o.set([1,0,0,0]);t.set([n.x[r],n.y[r],n.z[r]])}else{const t=new Uint16Array(u,S*a,3),s=new Uint16Array(p,S*c,3),o=new Uint16Array(g,S*h,4),i=e.DataUtils.toHalfFloat.bind(e.DataUtils);if(void 0!==n.scale_0[r]){const t=new e.Quaternion(n.rot_1[r],n.rot_2[r],n.rot_3[r],n.rot_0[r]);t.normalize(),o.set([i(t.w),i(t.x),i(t.y),i(t.z)]),s.set([i(n.scale_0[r]),i(n.scale_1[r]),i(n.scale_2[r])])}else s.set([i(.01),i(.01),i(.01)]),o.set([i(1),0,0,0]);b.set(n.x[r],n.y[r],n.z[r]).sub(v),b.x=Math.round(b.x*C)+A,b.x=f(b.x,0,w),b.y=Math.round(b.y*C)+A,b.y=f(b.y,0,w),b.z=Math.round(b.z*C)+A,b.z=f(b.z,0,w),t.set([b.x,b.y,b.z])}const i=new Uint8ClampedArray(m,S*l,4);o?(i[0]=255,i[1]=0,i[2]=0,i[3]=0):(void 0!==n.f_dc_0[r]?i.set([n.f_dc_0[r],n.f_dc_1[r],n.f_dc_2[r]]):i.set([255,0,0]),void 0!==n.opacity[r]?i[3]=n.opacity[r]:i[3]=255),S++}}const M=12*r.length,I=u.byteLength+p.byteLength+m.byteLength+g.byteLength,P=new Uint32Array(i.buffer),T=new Float32Array(i.buffer);let D=o+I;this.compressionLevel>0&&(D+=M,P[2]=this.bucketSize,P[3]=r.length,T[4]=this.blockSize,P[5]=12,P[6]=d.CompressionLevels[this.compressionLevel].ScaleRange);const B=new ArrayBuffer(D);if(new Uint8Array(B,0,o).set(i),new Uint8Array(B,o,u.byteLength).set(new Uint8Array(u)),new Uint8Array(B,o+u.byteLength,p.byteLength).set(new Uint8Array(p)),new Uint8Array(B,o+u.byteLength+p.byteLength,m.byteLength).set(new Uint8Array(m)),new Uint8Array(B,o+u.byteLength+p.byteLength+m.byteLength,g.byteLength).set(new Uint8Array(g)),this.compressionLevel>0){const e=new Float32Array(B,o+I,3*r.length);for(let t=0;t<r.length;t++){const n=r[t],s=3*t;e[s]=n.center[0],e[s+1]=n.center[1],e[s+2]=n.center[2]}}return new d(B)}computeBucketsForUncompressedSplatArray(t){let n=t.splatCount;const r=this.blockSize,s=r/2,o=new e.Vector3,i=new e.Vector3;for(let e=1;e<n;e++){const n=[t.x[e],t.y[e],t.z[e]];(0===e||n[0]<o.x)&&(o.x=n[0]),(0===e||n[0]>i.x)&&(i.x=n[0]),(0===e||n[1]<o.y)&&(o.y=n[1]),(0===e||n[1]>i.y)&&(i.y=n[1]),(0===e||n[2]<o.z)&&(o.z=n[2]),(0===e||n[2]>i.z)&&(i.z=n[2])}const a=(new e.Vector3).copy(i).sub(o),c=Math.ceil(a.y/r),l=Math.ceil(a.z/r),h=new e.Vector3,d=[],u={};for(let e=1;e<n;e++){const n=[t.x[e],t.y[e],t.z[e]],i=Math.floor((n[0]-o.x)/r),a=Math.floor((n[1]-o.y)/r),p=Math.floor((n[2]-o.z)/r);h.x=i*r+o.x+s,h.y=a*r+o.y+s,h.z=p*r+o.z+s;const m=i*(c*l)+a*l+p;let f=u[m];f||(u[m]=f={splats:[],center:h.toArray()}),f.splats.push(e),f.splats.length>=this.bucketSize&&(d.push(f),u[m]=null)}for(let e in u)if(u.hasOwnProperty(e)){const t=u[e];if(t){for(;t.splats.length<this.bucketSize;)t.splats.push(0);d.push(t)}}return d}}class C{constructor(e){this.plyBuffer=e}decodeHeader(e){const t=new TextDecoder;let n=0,r="";console.log(".PLY size: "+e.byteLength+" bytes");const s=100;for(;;){if(n+s>=e.byteLength)throw new Error("End of file reached while searching for end of header");const o=new Uint8Array(e,n,s);r+=t.decode(o),n+=s;const i=new Uint8Array(e,Math.max(0,n-200),200);if(t.decode(i).includes("end_header"))break}const o=r.split("\n");let i=0,a={};for(let e=0;e<o.length;e++){const t=o[e].trim();if(t.startsWith("element vertex")){const e=t.match(/\d+/);e&&(i=parseInt(e[0]))}else if(t.startsWith("property")){const e=t.match(/(\w+)\s+(\w+)\s+(\w+)/);if(e){const t=e[2];a[e[3]]=t}}else if("end_header"===t)break}const c=r.indexOf("end_header")+10+1;return{splatCount:i,propertyTypes:a,vertexData:new DataView(e,c),headerOffset:n}}readRawVertexFast(e,t,n,r,s,o){let i=o||{};for(let o of r){const r=s[o];"float"===r?i[o]=e.getFloat32(t+n[o],!0):"uchar"===r&&(i[o]=e.getUint8(t+n[o])/255)}}parseToSplatBuffer(e,t,n,r){const s=performance.now();console.log("Parsing PLY to SPLAT...");const{splatCount:o,propertyTypes:i,vertexData:a}=this.decodeHeader(this.plyBuffer);let c=0;for(const e in i)e.startsWith("f_rest_")&&(c+=1);const l=c/3;console.log("Detected degree",0,"with ",l,"coefficients per color");const h=[];for(let e=0;e<3;++e)h.push(`f_dc_${e}`);for(let e=0;e<l;++e)for(let t=0;t<3;++t)h.push(`f_rest_${t*l+e}`);let d=0,u={};const p={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1};for(let e in i)if(i.hasOwnProperty(e)){const t=i[e];u[e]=d,d+=p[t]}let m={};const f=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity"],g=x.createEmptyUncompressedSplatArray();for(let e=0;e<o;e++){if(this.readRawVertexFast(a,e*d,u,f,i,m),void 0!==m.scale_0?(g.scale_0[e]=Math.exp(m.scale_0),g.scale_1[e]=Math.exp(m.scale_1),g.scale_2[e]=Math.exp(m.scale_2)):(g.scale_0[e]=.01,g.scale_1[e]=.01,g.scale_2[e]=.01),void 0!==m.f_dc_0){const t=.28209479177387814;g.f_dc_0[e]=255*(.5+t*m.f_dc_0),g.f_dc_1[e]=255*(.5+t*m.f_dc_1),g.f_dc_2[e]=255*(.5+t*m.f_dc_2)}else g.f_dc_0[e]=0,g.f_dc_1[e]=0,g.f_dc_2[e]=0;void 0!==m.opacity&&(g.opacity[e]=1/(1+Math.exp(-m.opacity))*255),g.rot_0[e]=m.rot_0,g.rot_1[e]=m.rot_1,g.rot_2[e]=m.rot_2,g.rot_3[e]=m.rot_3,g.x[e]=m.x,g.y[e]=m.y,g.z[e]=m.z,g.splatCount++}const y=new x(e,t,n,r).uncompressedSplatArrayToSplatBuffer(g);console.log("Total valid splats: ",y.getSplatCount(),"out of",o);const A=performance.now();return console.log("Parsing PLY to SPLAT complete!"),console.log("Total time: ",(A-s).toFixed(2)+" ms"),y}}class w{constructor(){this.splatBuffer=null}loadFromURL(e,t,n,r,s,o){return m(e,t).then((e=>{const t=new C(e).parseToSplatBuffer(n,r,s,o);return this.splatBuffer=t,t}))}}const v={Splat:0,KSplat:1,Ply:2};class b{constructor(e=null){this.splatBuffer=e,this.downLoadLink=null}static isFileSplatFormat(e){return b.isCustomSplatFormat(e)||b.isStandardSplatFormat(e)}static isCustomSplatFormat(e){return e.endsWith(".ksplat")}static isStandardSplatFormat(e){return e.endsWith(".splat")}loadFromURL(e,t,n,r,s,o,i){return m(e,t).then((t=>{let a;if(i===v.KSplat||b.isCustomSplatFormat(e))a=new d(t);else{const e=new x(n,r,s,o),i=b.parseStandardSplatToUncompressedSplatArray(t);a=e.uncompressedSplatArrayToSplatBuffer(i)}return a}))}static parseStandardSplatToUncompressedSplatArray(t){const n=t.byteLength/32,r=x.createEmptyUncompressedSplatArray();for(let s=0;s<n;s++){const n=12,o=12,i=4,a=32*s,c=new Float32Array(t,a,3),l=new Float32Array(t,a+n,3),h=new Uint8Array(t,a+n+o,4),d=new Uint8Array(t,a+n+o+i,4),u=new e.Quaternion((d[1]-128)/128,(d[2]-128)/128,(d[3]-128)/128,(d[0]-128)/128);u.normalize(),r.addSplat(c[0],c[1],c[2],l[0],l[1],l[2],u.w,u.x,u.y,u.z,h[0],h[1],h[2],h[3])}return r}setFromBuffer(e){this.splatBuffer=e}downloadFile(e){const t=new Uint8Array(this.splatBuffer.getHeaderBufferData()),n=new Uint8Array(this.splatBuffer.getSplatBufferData()),r=new Blob([t.buffer,n.buffer],{type:"application/octet-stream"});this.downLoadLink||(this.downLoadLink=document.createElement("a"),document.body.appendChild(this.downLoadLink)),this.downLoadLink.download=e,this.downLoadLink.href=URL.createObjectURL(r),this.downLoadLink.click()}}const S={type:"change"},M={type:"start"},I={type:"end"},P=new t,T=new n,D=Math.cos(70*r.DEG2RAD);class B extends s{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new o,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:i.ROTATE,MIDDLE:i.DOLLY,RIGHT:i.PAN},this.touches={ONE:a.ROTATE,TWO:a.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return u.phi},this.getAzimuthalAngle=function(){return u.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",se),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",se),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(S),n.update(),s=r.NONE},this.update=function(){const t=new o,i=(new c).setFromUnitVectors(e.up,new o(0,1,0)),a=i.clone().invert(),l=new o,h=new c,g=new o,y=2*Math.PI;return function(){i.setFromUnitVectors(e.up,new o(0,1,0)),a.copy(i).invert();const c=n.object.position;t.copy(c).sub(n.target),t.applyQuaternion(i),u.setFromVector3(t),n.autoRotate&&s===r.NONE&&z(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(u.theta+=p.theta*n.dampingFactor,u.phi+=p.phi*n.dampingFactor):(u.theta+=p.theta,u.phi+=p.phi);let A=n.minAzimuthAngle,x=n.maxAzimuthAngle;isFinite(A)&&isFinite(x)&&(A<-Math.PI?A+=y:A>Math.PI&&(A-=y),x<-Math.PI?x+=y:x>Math.PI&&(x-=y),u.theta=A<=x?Math.max(A,Math.min(x,u.theta)):u.theta>(A+x)/2?Math.max(A,u.theta):Math.min(x,u.theta)),u.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,u.phi)),u.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(f,n.dampingFactor):n.target.add(f),n.zoomToCursor&&R||n.object.isOrthographicCamera?u.radius=W(u.radius):u.radius=W(u.radius*m),t.setFromSpherical(u),t.applyQuaternion(a),c.copy(n.target).add(t),n.object.lookAt(n.target),!0===n.enableDamping?(p.theta*=1-n.dampingFactor,p.phi*=1-n.dampingFactor,f.multiplyScalar(1-n.dampingFactor)):(p.set(0,0,0),f.set(0,0,0));let C=!1;if(n.zoomToCursor&&R){let r=null;if(n.object.isPerspectiveCamera){const e=t.length();r=W(e*m);const s=e-r;n.object.position.addScaledVector(F,s),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const e=new o(E.x,E.y,0);e.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),C=!0;const s=new o(E.x,E.y,0);s.unproject(n.object),n.object.position.sub(s).add(e),n.object.updateMatrixWorld(),r=t.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==r&&(this.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(r).add(n.object.position):(P.origin.copy(n.object.position),P.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(P.direction))<D?e.lookAt(n.target):(T.setFromNormalAndCoplanarPoint(n.object.up,n.target),P.intersectPlane(T,n.target))))}else n.object.isOrthographicCamera&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),C=!0);return m=1,R=!1,!!(C||l.distanceToSquared(n.object.position)>d||8*(1-h.dot(n.object.quaternion))>d||g.distanceToSquared(n.target)>0)&&(n.dispatchEvent(S),l.copy(n.object.position),h.copy(n.object.quaternion),g.copy(n.target),C=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",oe),n.domElement.removeEventListener("pointerdown",ee),n.domElement.removeEventListener("pointercancel",ne),n.domElement.removeEventListener("wheel",re),n.domElement.removeEventListener("pointermove",te),n.domElement.removeEventListener("pointerup",ne),null!==n._domElementKeyEvents&&(n._domElementKeyEvents.removeEventListener("keydown",se),n._domElementKeyEvents=null)};const n=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let s=r.NONE;const d=1e-6,u=new l,p=new l;let m=1;const f=new o,g=new h,y=new h,A=new h,x=new h,C=new h,w=new h,v=new h,b=new h,B=new h,F=new o,E=new h;let R=!1;const k=[],L={};function _(){return Math.pow(.95,n.zoomSpeed)}function z(e){p.theta-=e}function V(e){p.phi-=e}const U=function(){const e=new o;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),f.add(e)}}(),O=function(){const e=new o;return function(t,r){!0===n.screenSpacePanning?e.setFromMatrixColumn(r,1):(e.setFromMatrixColumn(r,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),f.add(e)}}(),N=function(){const e=new o;return function(t,r){const s=n.domElement;if(n.object.isPerspectiveCamera){const o=n.object.position;e.copy(o).sub(n.target);let i=e.length();i*=Math.tan(n.object.fov/2*Math.PI/180),U(2*t*i/s.clientHeight,n.object.matrix),O(2*r*i/s.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(U(t*(n.object.right-n.object.left)/n.object.zoom/s.clientWidth,n.object.matrix),O(r*(n.object.top-n.object.bottom)/n.object.zoom/s.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function Q(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function j(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function H(t){if(!n.zoomToCursor)return;R=!0;const r=n.domElement.getBoundingClientRect(),s=t.clientX-r.left,o=t.clientY-r.top,i=r.width,a=r.height;E.x=s/i*2-1,E.y=-o/a*2+1,F.set(E.x,E.y,1).unproject(e).sub(e.position).normalize()}function W(e){return Math.max(n.minDistance,Math.min(n.maxDistance,e))}function G(e){g.set(e.clientX,e.clientY)}function Y(e){x.set(e.clientX,e.clientY)}function K(){if(1===k.length)g.set(k[0].pageX,k[0].pageY);else{const e=.5*(k[0].pageX+k[1].pageX),t=.5*(k[0].pageY+k[1].pageY);g.set(e,t)}}function X(){if(1===k.length)x.set(k[0].pageX,k[0].pageY);else{const e=.5*(k[0].pageX+k[1].pageX),t=.5*(k[0].pageY+k[1].pageY);x.set(e,t)}}function q(){const e=k[0].pageX-k[1].pageX,t=k[0].pageY-k[1].pageY,n=Math.sqrt(e*e+t*t);v.set(0,n)}function J(e){if(1==k.length)y.set(e.pageX,e.pageY);else{const t=ae(e),n=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);y.set(n,r)}A.subVectors(y,g).multiplyScalar(n.rotateSpeed);const t=n.domElement;z(2*Math.PI*A.x/t.clientHeight),V(2*Math.PI*A.y/t.clientHeight),g.copy(y)}function Z(e){if(1===k.length)C.set(e.pageX,e.pageY);else{const t=ae(e),n=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);C.set(n,r)}w.subVectors(C,x).multiplyScalar(n.panSpeed),N(w.x,w.y),x.copy(C)}function $(e){const t=ae(e),r=e.pageX-t.x,s=e.pageY-t.y,o=Math.sqrt(r*r+s*s);b.set(0,o),B.set(0,Math.pow(b.y/v.y,n.zoomSpeed)),Q(B.y),v.copy(b)}function ee(e){!1!==n.enabled&&(0===k.length&&(n.domElement.setPointerCapture(e.pointerId),n.domElement.addEventListener("pointermove",te),n.domElement.addEventListener("pointerup",ne)),function(e){k.push(e)}(e),"touch"===e.pointerType?function(e){switch(ie(e),k.length){case 1:switch(n.touches.ONE){case a.ROTATE:if(!1===n.enableRotate)return;K(),s=r.TOUCH_ROTATE;break;case a.PAN:if(!1===n.enablePan)return;X(),s=r.TOUCH_PAN;break;default:s=r.NONE}break;case 2:switch(n.touches.TWO){case a.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&q(),n.enablePan&&X(),s=r.TOUCH_DOLLY_PAN;break;case a.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&q(),n.enableRotate&&K(),s=r.TOUCH_DOLLY_ROTATE;break;default:s=r.NONE}break;default:s=r.NONE}s!==r.NONE&&n.dispatchEvent(M)}(e):function(e){let t;switch(e.button){case 0:t=n.mouseButtons.LEFT;break;case 1:t=n.mouseButtons.MIDDLE;break;case 2:t=n.mouseButtons.RIGHT;break;default:t=-1}switch(t){case i.DOLLY:if(!1===n.enableZoom)return;!function(e){H(e),v.set(e.clientX,e.clientY)}(e),s=r.DOLLY;break;case i.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;Y(e),s=r.PAN}else{if(!1===n.enableRotate)return;G(e),s=r.ROTATE}break;case i.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;G(e),s=r.ROTATE}else{if(!1===n.enablePan)return;Y(e),s=r.PAN}break;default:s=r.NONE}s!==r.NONE&&n.dispatchEvent(M)}(e))}function te(e){!1!==n.enabled&&("touch"===e.pointerType?function(e){switch(ie(e),s){case r.TOUCH_ROTATE:if(!1===n.enableRotate)return;J(e),n.update();break;case r.TOUCH_PAN:if(!1===n.enablePan)return;Z(e),n.update();break;case r.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(e){n.enableZoom&&$(e),n.enablePan&&Z(e)}(e),n.update();break;case r.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(e){n.enableZoom&&$(e),n.enableRotate&&J(e)}(e),n.update();break;default:s=r.NONE}}(e):function(e){switch(s){case r.ROTATE:if(!1===n.enableRotate)return;!function(e){y.set(e.clientX,e.clientY),A.subVectors(y,g).multiplyScalar(n.rotateSpeed);const t=n.domElement;z(2*Math.PI*A.x/t.clientHeight),V(2*Math.PI*A.y/t.clientHeight),g.copy(y),n.update()}(e);break;case r.DOLLY:if(!1===n.enableZoom)return;!function(e){b.set(e.clientX,e.clientY),B.subVectors(b,v),B.y>0?Q(_()):B.y<0&&j(_()),v.copy(b),n.update()}(e);break;case r.PAN:if(!1===n.enablePan)return;!function(e){C.set(e.clientX,e.clientY),w.subVectors(C,x).multiplyScalar(n.panSpeed),N(w.x,w.y),x.copy(C),n.update()}(e)}}(e))}function ne(e){!function(e){delete L[e.pointerId];for(let t=0;t<k.length;t++)if(k[t].pointerId==e.pointerId)return void k.splice(t,1)}(e),0===k.length&&(n.domElement.releasePointerCapture(e.pointerId),n.domElement.removeEventListener("pointermove",te),n.domElement.removeEventListener("pointerup",ne)),n.dispatchEvent(I),s=r.NONE}function re(e){!1!==n.enabled&&!1!==n.enableZoom&&s===r.NONE&&(e.preventDefault(),n.dispatchEvent(M),function(e){H(e),e.deltaY<0?j(_()):e.deltaY>0&&Q(_()),n.update()}(e),n.dispatchEvent(I))}function se(e){!1!==n.enabled&&!1!==n.enablePan&&function(e){let t=!1;switch(e.code){case n.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?V(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?V(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?z(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?z(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(-n.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),n.update())}(e)}function oe(e){!1!==n.enabled&&e.preventDefault()}function ie(e){let t=L[e.pointerId];void 0===t&&(t=new h,L[e.pointerId]=t),t.set(e.pageX,e.pageY)}function ae(e){const t=e.pointerId===k[0].pointerId?k[1]:k[0];return L[t.pointerId]}n.domElement.addEventListener("contextmenu",oe),n.domElement.addEventListener("pointerdown",ee),n.domElement.addEventListener("pointercancel",ne),n.domElement.addEventListener("wheel",re,{passive:!1}),this.update()}}class F{constructor(e,t){this.message=e||"Loading...",this.container=t||document.body,this.spinnerDivContainerOuter=document.createElement("div"),this.spinnerDivContainerOuter.className="outerContainer",this.spinnerDivContainerOuter.style.display="none",this.spinnerDivContainer=document.createElement("div"),this.spinnerDivContainer.className="container",this.spinnerDiv=document.createElement("div"),this.spinnerDiv.className="loader",this.messageDiv=document.createElement("div"),this.messageDiv.className="message",this.messageDiv.innerHTML=this.message,this.spinnerDivContainer.appendChild(this.spinnerDiv),this.spinnerDivContainer.appendChild(this.messageDiv),this.spinnerDivContainerOuter.appendChild(this.spinnerDivContainer),this.container.appendChild(this.spinnerDivContainerOuter);const n=document.createElement("style");n.innerHTML="\n\n            .message {\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                padding-top:15px;\n                width: 180px;\n            }\n\n            .outerContainer {\n                width: 100%;\n                height: 100%;\n            }\n\n            .container {\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n            }\n\n            .loader {\n                width: 120px;        /* the size */\n                padding: 15px;       /* the border thickness */\n                background: #07e8d6; /* the color */\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n                margin-left: 30px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        ",this.spinnerDivContainerOuter.appendChild(n)}show(){this.spinnerDivContainerOuter.style.display="block"}hide(){this.spinnerDivContainerOuter.style.display="none"}setContainer(e){this.container&&this.container.removeChild(this.spinnerDivContainerOuter),this.container=e,this.container.appendChild(this.spinnerDivContainerOuter),this.spinnerDivContainerOuter.style.zIndex=this.container.style.zIndex+1}setMessage(e){this.messageDiv.innerHTML=e}}class E extends e.Object3D{constructor(t=new e.Vector3(0,0,1),n=new e.Vector3(0,0,0),r=1,s=.1,o=16776960,i=.2*r,a=.2*i){super(),this.type="ArrowHelper";const c=new e.CylinderGeometry(s,s,r,32);c.translate(0,r/2,0);const l=new e.CylinderGeometry(0,a,i,32);l.translate(0,r,0),this.position.copy(n),this.line=new e.Mesh(c,new e.MeshBasicMaterial({color:o,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new e.Mesh(l,new e.MeshBasicMaterial({color:o,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(_axis,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class R{constructor(e){this.threeScene=e,this.splatRenderTarget=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null,this.debugRoot=null,this.secondaryDebugRoot=null}updateSplatRenderTargetForRenderDimensions(t,n){this.destroySplatRendertarget(),this.splatRenderTarget=new e.WebGLRenderTarget(t,n,{format:e.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new e.DepthTexture(t,n),this.splatRenderTarget.depthTexture.format=e.DepthFormat,this.splatRenderTarget.depthTexture.type=e.UnsignedIntType}destroySplatRendertarget(){this.splatRenderTarget&&(this.splatRenderTarget=null)}setupRenderTargetCopyObjects(){const t=new e.ShaderMaterial({vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",uniforms:{sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},depthWrite:!1,depthTest:!1,transparent:!0,blending:e.CustomBlending,blendSrc:e.SrcAlphaFactor,blendSrcAlpha:e.SrcAlphaFactor,blendDst:e.OneMinusSrcAlphaFactor,blendDstAlpha:e.OneMinusSrcAlphaFactor});t.extensions.fragDepth=!0,this.renderTargetCopyQuad=new e.Mesh(new e.PlaneGeometry(2,2),t),this.renderTargetCopyCamera=new e.OrthographicCamera(-1,1,1,-1,0,1)}destroyRenderTargetCopyObjects(){this.renderTargetCopyQuad&&(y(this.renderTargetCopyQuad),this.renderTargetCopyQuad=null)}setupMeshCursor(){if(!this.meshCursor){const t=new e.ConeGeometry(.5,1.5,32),n=new e.MeshBasicMaterial({color:16777215}),r=new e.Mesh(t,n);r.rotation.set(0,0,Math.PI),r.position.set(0,1,0);const s=new e.Mesh(t,n);s.position.set(0,-1,0);const o=new e.Mesh(t,n);o.rotation.set(0,0,Math.PI/2),o.position.set(1,0,0);const i=new e.Mesh(t,n);i.rotation.set(0,0,-Math.PI/2),i.position.set(-1,0,0),this.meshCursor=new e.Object3D,this.meshCursor.add(r),this.meshCursor.add(s),this.meshCursor.add(o),this.meshCursor.add(i),this.meshCursor.scale.set(.1,.1,.1),this.threeScene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(y(this.meshCursor),this.threeScene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const t=new e.SphereGeometry(.5,32,32),n=R.buildFocusMarkerMaterial();n.depthTest=!1,n.depthWrite=!1,n.transparent=!0,this.focusMarker=new e.Mesh(t,n)}}destroyFocusMarker(){this.focusMarker&&(y(this.focusMarker),this.focusMarker=null)}updateFocusMarker=function(){const t=new e.Vector3,n=new e.Matrix4;return function(e,r,s){n.copy(r.matrixWorld).invert(),t.copy(e).applyMatrix4(n),t.normalize().multiplyScalar(10),t.applyMatrix4(r.matrixWorld),this.focusMarker.position.copy(t),this.focusMarker.material.uniforms.realFocusPosition.value.copy(e),this.focusMarker.material.uniforms.viewport.value.copy(s),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){if(!this.controlPlane){const t=new e.PlaneGeometry(1,1);t.rotateX(-Math.PI/2);const n=new e.MeshBasicMaterial({color:16777215});n.transparent=!0,n.opacity=.6,n.depthTest=!1,n.depthWrite=!1,n.side=e.DoubleSide;const r=new e.Mesh(t,n),s=new e.Vector3(0,1,0);s.normalize();const o=new e.Vector3(0,0,0),i=new E(s,o,.5,.01,56576,.1,.03);this.controlPlane=new e.Object3D,this.controlPlane.add(r),this.controlPlane.add(i)}}destroyControlPlane(){this.controlPlane&&(y(this.controlPlane),this.controlPlane=null)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const t=new e.Quaternion,n=new e.Vector3(0,1,0);return function(e,r){t.setFromUnitVectors(n,r),this.controlPlane.position.copy(e),this.controlPlane.quaternion.copy(t)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.threeScene.add(this.debugRoot),this.threeScene.add(this.secondaryDebugRoot)}destroyDebugMeshes(){for(let e of[this.debugRoot,this.secondaryDebugRoot])e&&(y(e),this.threeScene.remove(e));this.debugRoot=null,this.secondaryDebugRoot=null}createDebugMeshes(t){const n=new e.SphereGeometry(1,32,32),r=new e.Object3D,s=(s,o)=>{let i=new e.Mesh(n,R.buildDebugMaterial(s));i.renderOrder=t,r.add(i),i.position.fromArray(o)};return s(16711680,[-50,0,0]),s(16711680,[50,0,0]),s(65280,[0,0,-50]),s(65280,[0,0,50]),s(16755200,[5,0,5]),r}createSecondaryDebugMeshes(t){const n=new e.BoxGeometry(3,3,3),r=new e.Object3D;const s=s=>{let o=new e.Mesh(n,R.buildDebugMaterial(12303291));o.renderOrder=t,r.add(o),o.position.fromArray(s)};let o=10;return s([-10,0,-10]),s([-10,0,o]),s([o,0,-10]),s([o,0,o]),r}static buildDebugMaterial(t){const n={color:{type:"v3",value:new e.Color(t)}},r=new e.ShaderMaterial({uniforms:n,vertexShader:"\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",transparent:!1,depthTest:!0,depthWrite:!0,side:e.FrontSide});return r.extensions.fragDepth=!0,r}static buildFocusMarkerMaterial(t){const n={color:{type:"v3",value:new e.Color(t)},realFocusPosition:{type:"v3",value:new e.Vector3},viewport:{type:"v2",value:new e.Vector2},opacity:{value:0}};return new e.ShaderMaterial({uniforms:n,vertexShader:"\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",transparent:!0,depthTest:!1,depthWrite:!1,side:e.FrontSide})}dispose(){this.destroyMeshCursor(),this.destroyFocusMarker(),this.destroyDebugMeshes(),this.destroyControlPlane(),this.destroyRenderTargetCopyObjects(),this.destroySplatRendertarget()}}const k=new e.Vector3(1,0,0),L=new e.Vector3(0,1,0),_=new e.Vector3(0,0,1);class z{constructor(t=new e.Vector3,n=new e.Vector3){this.origin=new e.Vector3,this.direction=new e.Vector3,this.setParameters(t,n)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,n){return!(t.x<e.min.x-n||t.x>e.max.x+n||t.y<e.min.y-n||t.y>e.max.y+n||t.z<e.min.z-n||t.z>e.max.z+n)}intersectBox=function(){const t=new e.Vector3,n=[],r=[],s=[];return function(e,o){if(r[0]=this.origin.x,r[1]=this.origin.y,r[2]=this.origin.z,s[0]=this.direction.x,s[1]=this.direction.y,s[2]=this.direction.z,this.boxContainsPoint(e,this.origin,1e-4))return o&&(o.origin.copy(this.origin),o.normal.set(0,0,0),o.distance=-1),!0;for(let i=0;i<3;i++){if(0==s[i])continue;const a=0==i?k:1==i?L:_,c=s[i]<0?e.max:e.min;let l=-Math.sign(s[i]);n[0]=0==i?c.x:1==i?c.y:c.z;let h=n[0]-r[i];if(h*l<0){const c=(i+1)%3,d=(i+2)%3;if(n[2]=s[c]/s[i]*h+r[c],n[1]=s[d]/s[i]*h+r[d],t.set(n[i],n[d],n[c]),this.boxContainsPoint(e,t,1e-4))return o&&(o.origin.copy(t),o.normal.copy(a).multiplyScalar(l),o.distance=t.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const t=new e.Vector3;return function(e,n,r){t.copy(e).sub(this.origin);const s=t.dot(this.direction),o=s*s,i=t.dot(t)-o,a=n*n;if(i>a)return!1;const c=Math.sqrt(a-i),l=s-c,h=s+c;if(h<0)return!1;let d=l<0?h:l;return r&&(r.origin.copy(this.origin).addScaledVector(this.direction,d),r.normal.copy(r.origin).sub(e).normalize(),r.distance=d),!0}}()}class V{constructor(){this.origin=new e.Vector3,this.normal=new e.Vector3,this.distance=0,this.splatIndex=0}set(e,t,n,r){this.origin.copy(e),this.normal.copy(t),this.distance=n,this.splatIndex=r}clone(){const e=new V;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e.splatIndex=this.splatIndex,e}}class U{constructor(e,t,n=!1){this.ray=new z(e,t),this.raycastAgainstTrueSplatEllipsoid=n}setFromCameraAndScreenPosition=function(){const t=new e.Vector2;return function(e,n,r){if(t.x=n.x/r.x*2-1,t.y=(r.y-n.y)/r.y*2-1,e.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e;else{if(!e.isOrthographicCamera)throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e}}}();intersectSplatMesh=function(){const t=new e.Matrix4,n=new e.Matrix4,r=new e.Matrix4,s=new z,o=new e.Vector3;return function(e,i=[]){const a=e.getSplatTree();for(let c=0;c<a.subTrees.length;c++){const l=a.subTrees[c];n.copy(e.matrixWorld),e.getSceneTransform(c,r),n.multiply(r),t.copy(n).invert(),s.origin.copy(this.ray.origin).applyMatrix4(t),s.direction.copy(this.ray.origin).add(this.ray.direction),s.direction.applyMatrix4(t).sub(s.origin).normalize();const h=[];l.rootNode&&this.castRayAtSplatTreeNode(s,a,l.rootNode,h),h.forEach((e=>{e.origin.applyMatrix4(n),e.normal.applyMatrix4(n).normalize(),e.distance=o.copy(e.origin).sub(this.ray.origin).length()})),i.push(...h)}return i.sort(((e,t)=>e.distance>t.distance?1:-1)),i}}();castRayAtSplatTreeNode=function(){const t=new e.Vector4,n=new e.Vector3,r=new e.Vector3,s=new e.Quaternion,o=new V,i=1e-7,a=new e.Vector3(0,0,0),c=new e.Matrix4,l=new e.Matrix4,h=new e.Matrix4,d=new e.Matrix4,u=new e.Matrix4,p=new z;return function(e,m,f,g=[]){if(e.intersectBox(f.boundingBox)){if(f.data.indexes&&f.data.indexes.length>0)for(let y=0;y<f.data.indexes.length;y++){const A=f.data.indexes[y];if(m.splatMesh.getSplatColor(A,t,!1),m.splatMesh.getSplatCenter(A,n,!1),m.splatMesh.getSplatScaleAndRotation(A,r,s,!1),!(r.x<=i||r.y<=i||r.z<=i))if(this.raycastAgainstTrueSplatEllipsoid){l.makeScale(r.x,r.y,r.z),h.makeRotationFromQuaternion(s);const i=2*Math.log10(t.w);if(c.makeScale(i,i,i),u.copy(c).multiply(h).multiply(l),d.copy(u).invert(),p.origin.copy(e.origin).sub(n).applyMatrix4(d),p.direction.copy(e.origin).add(e.direction).sub(n),p.direction.applyMatrix4(d).sub(p.origin).normalize(),p.intersectSphere(a,1,o)){const e=o.clone();e.splatIndex=A,e.origin.applyMatrix4(u).add(n),g.push(e)}}else{const t=(r.x+r.y+r.z)/3;if(e.intersectSphere(n,t,o)){const e=o.clone();e.splatIndex=A,g.push(e)}}}if(f.children&&f.children.length>0)for(let t of f.children)this.castRayAtSplatTreeNode(e,m,t,g);return g}}}()}class O{constructor(t,n=new e.Vector3,r=new e.Quaternion,s=new e.Vector3(1,1,1)){this.splatBuffer=t,this.position=n.clone(),this.quaternion=r.clone(),this.scale=s.clone(),this.transform=new e.Matrix4,this.updateTransform()}copyTransformData(e){this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.transform.copy(e.transform)}updateTransform(){this.transform.compose(this.position,this.quaternion,this.scale)}}let N=0;class Q{constructor(t,n,r,s){this.min=(new e.Vector3).copy(t),this.max=(new e.Vector3).copy(n),this.boundingBox=new e.Box3(this.min,this.max),this.center=(new e.Vector3).copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=r,this.children=[],this.data=null,this.id=s||N++}}class j{constructor(t,n){this.maxDepth=t,this.maxCentersPerNode=n,this.sceneDimensions=new e.Vector3,this.sceneMin=new e.Vector3,this.sceneMax=new e.Vector3,this.splatMesh=null,this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[]}}class H{constructor(e,t){this.maxDepth=e,this.maxCentersPerNode=t,this.splatMesh=null,this.subTrees=[]}processSplatMesh(t,n=(()=>!0)){this.splatMesh=t,this.subTrees=[];const r=new e.Vector3,s=function(e,s,o,i){const a=new j(o,i);let c=0;const l=[];for(let o=0;o<s;o++){const s=o+e;n(s)&&(t.getSplatCenter(s,r),(0===c||r.x<a.sceneMin.x)&&(a.sceneMin.x=r.x),(0===c||r.x>a.sceneMax.x)&&(a.sceneMax.x=r.x),(0===c||r.y<a.sceneMin.y)&&(a.sceneMin.y=r.y),(0===c||r.y>a.sceneMax.y)&&(a.sceneMax.y=r.y),(0===c||r.z<a.sceneMin.z)&&(a.sceneMin.z=r.z),(0===c||r.z>a.sceneMax.z)&&(a.sceneMax.z=r.z),c++,l.push(s))}return a.sceneDimensions.copy(a.sceneMax).sub(a.sceneMin),a.rootNode=new Q(a.sceneMin,a.sceneMax,0),a.rootNode.data={indexes:l},a};if(t.dynamicMode){let e=0;for(let n=0;n<t.scenes.length;n++){const r=t.getScene(n).splatBuffer.getSplatCount(),o=s(e,r,this.maxDepth,this.maxCentersPerNode);this.subTrees[n]=o,H.processNode(o,o.rootNode,t),e+=r}}else{const e=s(0,t.getSplatCount(),this.maxDepth,this.maxCentersPerNode);this.subTrees[0]=e,H.processNode(e,e.rootNode,t)}}static processNode(t,n,r){const s=n.data.indexes.length;if(s<t.maxCentersPerNode||n.depth>t.maxDepth){const e=[];for(let r=0;r<n.data.indexes.length;r++)t.addedIndexes[n.data.indexes[r]]||(e.push(n.data.indexes[r]),t.addedIndexes[n.data.indexes[r]]=!0);return n.data.indexes=e,void t.nodesWithIndexes.push(n)}const o=(new e.Vector3).copy(n.max).sub(n.min),i=(new e.Vector3).copy(o).multiplyScalar(.5),a=(new e.Vector3).copy(n.min).add(i),c=[new e.Box3(new e.Vector3(a.x-i.x,a.y,a.z-i.z),new e.Vector3(a.x,a.y+i.y,a.z)),new e.Box3(new e.Vector3(a.x,a.y,a.z-i.z),new e.Vector3(a.x+i.x,a.y+i.y,a.z)),new e.Box3(new e.Vector3(a.x,a.y,a.z),new e.Vector3(a.x+i.x,a.y+i.y,a.z+i.z)),new e.Box3(new e.Vector3(a.x-i.x,a.y,a.z),new e.Vector3(a.x,a.y+i.y,a.z+i.z)),new e.Box3(new e.Vector3(a.x-i.x,a.y-i.y,a.z-i.z),new e.Vector3(a.x,a.y,a.z)),new e.Box3(new e.Vector3(a.x,a.y-i.y,a.z-i.z),new e.Vector3(a.x+i.x,a.y,a.z)),new e.Box3(new e.Vector3(a.x,a.y-i.y,a.z),new e.Vector3(a.x+i.x,a.y,a.z+i.z)),new e.Box3(new e.Vector3(a.x-i.x,a.y-i.y,a.z),new e.Vector3(a.x,a.y,a.z+i.z))],l=[],h=[];for(let e=0;e<c.length;e++)l[e]=0,h[e]=[];const d=new e.Vector3;for(let e=0;e<s;e++){const t=n.data.indexes[e];r.getSplatCenter(t,d);for(let e=0;e<c.length;e++)c[e].containsPoint(d)&&(l[e]++,h[e].push(t))}for(let e=0;e<c.length;e++){const t=new Q(c[e].min,c[e].max,n.depth+1);t.data={indexes:h[e]},n.children.push(t)}n.data={};for(let e of n.children)H.processNode(t,e,r)}countLeaves(){let e=0;return this.visitLeaves((()=>{e++})),e}visitLeaves(e){const t=(e,n)=>{0===e.children.length&&n(e);for(let r of e.children)t(r,n)};for(let n of this.subTrees)t(n.rootNode,e)}}class W{static DepthMapRange=65536;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4;static MaxScenes=32}const G=new e.BufferGeometry,Y=new e.MeshBasicMaterial;class K extends e.Mesh{constructor(e=!0,t=!1,n=1,r=!0,s=!1){super(G,Y),this.renderer=void 0,this.halfPrecisionCovariancesOnGPU=t,this.dynamicMode=e,this.devicePixelRatio=n,this.enableDistancesComputationOnGPU=r,this.integerBasedDistancesComputation=s,this.scenes=[],this.splatTree=null,this.splatDataTextures=null,this.distancesTransformFeedback={id:null,vertexShader:null,fragmentShader:null,program:null,centersBuffer:null,transformIndexesBuffer:null,outDistancesBuffer:null,centersLoc:-1,modelViewProjLoc:-1,transformIndexesLoc:-1,transformsLocs:[]},this.globalSplatIndexToLocalSplatIndexMap=[],this.globalSplatIndexToSceneIndexMap=[]}static buildMaterial(t=!1){let n="\n            precision highp float;\n            #include <common>\n\n            attribute uint splatIndex;\n\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D centersColorsTexture;";t&&(n+=`\n                uniform highp usampler2D transformIndexesTexture;\n                uniform highp mat4 transforms[${W.MaxScenes}];\n                uniform vec2 transformIndexesTextureSize;\n            `),n+="\n            uniform vec2 focal;\n            uniform vec2 viewport;\n            uniform vec2 basisViewport;\n            uniform vec2 covariancesTextureSize;\n            uniform vec2 centersColorsTextureSize;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            const float sqrt8 = sqrt(8.0);\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            void main () {\n\n                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));",n+=t?"\n                    uint transformIndex = texture(transformIndexesTexture, getDataUV(1, 0, transformIndexesTextureSize)).r;\n                    mat4 transform = transforms[transformIndex];\n                    mat4 transformModelViewMatrix = modelViewMatrix * transform;\n                ":"mat4 transformModelViewMatrix = modelViewMatrix;",n+="\n                vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);\n\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                float clip = 1.2 * clipCenter.w;\n                if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {\n                    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n                    return;\n                }\n\n                vPosition = position.xy;\n                vColor = uintToRGBAVec(sampledCenterColor.r);\n\n                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;\n\n                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);\n                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);\n\n                // Construct the 3D covariance matrix\n                mat3 Vrk = mat3(\n                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n                );\n\n                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the\n                // 3D covariance matrix instead of using the actual projection matrix because that transformation would\n                // require a non-linear component (perspective division) which would yield a non-gaussian result. (This assumes\n                // the current projection is a perspective projection).\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n\n                // Concatenate the projection approximation with the model-view transformation\n                mat3 W = transpose(mat3(transformModelViewMatrix));\n                mat3 T = W * J;\n\n                // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix\n                mat3 cov2Dm = transpose(T) * Vrk * T;\n\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n\n                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n                // need cov2Dm[1][0] because it is a symetric matrix.\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n                // so that we can determine the 2D basis for the splat. This is done using the method described\n                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n                // After calculating the eigen-values and eigen-vectors, we calculate the basis for rendering the splat\n                // by normalizing the eigen-vectors and then multiplying them by (sqrt(8) * eigen-value), which is\n                // equal to scaling them by sqrt(8) standard deviations.\n                //\n                // This is a different approach than in the original work at INRIA. In that work they compute the\n                // max extents of the projected splat in screen space to form a screen-space aligned bounding rectangle\n                // which forms the geometry that is actually rasterized. The dimensions of that bounding box are 3.0\n                // times the maximum eigen-value, or 3 standard deviations. They then use the inverse 2D covariance\n                // matrix (called 'conic') in the CUDA rendering thread to determine fragment opacity by calculating the\n                // full gaussian: exp(-0.5 * (X - mean) * conic * (X - mean)) * splat opacity\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = traceOver2 - term2;\n\n                float transparentAdjust = step(1.0 / 255.0, vColor.a);\n                eigenValue2 = eigenValue2 * transparentAdjust; // hide splat if alpha is zero\n\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                // since the eigen vectors are orthogonal, we derive the second one from the first\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n\n                // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.\n                vec2 basisVector1 = eigenVector1 * sqrt8 * sqrt(eigenValue1);\n                vec2 basisVector2 = eigenVector2 * sqrt8 * sqrt(eigenValue2);\n\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport * 2.0;\n\n                // Similarly scale the position data we send to the fragment shader\n                vPosition *= sqrt8;\n\n                gl_Position = vec4(ndcCenter.xy  + ndcOffset, ndcCenter.z, 1.0);\n\n            }";const r={covariancesTexture:{type:"t",value:null},centersColorsTexture:{type:"t",value:null},focal:{type:"v2",value:new e.Vector2},viewport:{type:"v2",value:new e.Vector2},basisViewport:{type:"v2",value:new e.Vector2},debugColor:{type:"v3",value:new e.Color},covariancesTextureSize:{type:"v2",value:new e.Vector2(1024,1024)},centersColorsTextureSize:{type:"v2",value:new e.Vector2(1024,1024)}};if(t){r.transformIndexesTexture={type:"t",value:null};const t=[];for(let n=0;n<W.MaxScenes;n++)t.push(new e.Matrix4);r.transforms={type:"mat4",value:t},r.transformIndexesTextureSize={type:"v2",value:new e.Vector2(1024,1024)}}return new e.ShaderMaterial({uniforms:r,vertexShader:n,fragmentShader:"\n            precision highp float;\n            #include <common>\n \n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            void main () {\n                // Compute the positional squared distance from the center of the splat to the current fragment.\n                float A = dot(vPosition, vPosition);\n                // Since the positional data in vPosition has been scaled by sqrt(8), the squared result will be\n                // scaled by a factor of 8. If the squared result is larger than 8, it means it is outside the ellipse\n                // defined by the rectangle formed by vPosition. It also means it's farther\n                // away than sqrt(8) standard deviations from the mean.\n                if (A > 8.0) discard;\n                vec3 color = vColor.rgb;\n\n                // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of\n                // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),\n                // and since 'mean' is zero, we have X * X, which is the same as A:\n                float opacity = exp(-0.5 * A) * vColor.a;\n\n                gl_FragColor = vec4(color.rgb, opacity);\n            }",transparent:!0,alphaTest:1,blending:e.NormalBlending,depthTest:!0,depthWrite:!1,side:e.DoubleSide})}static buildGeomtery(t){const n=new e.BufferGeometry;n.setIndex([0,1,2,0,2,3]);const r=new Float32Array(12),s=new e.BufferAttribute(r,3);n.setAttribute("position",s),s.setXYZ(0,-1,-1,0),s.setXYZ(1,-1,1,0),s.setXYZ(2,1,1,0),s.setXYZ(3,1,-1,0),s.needsUpdate=!0;const o=(new e.InstancedBufferGeometry).copy(n),i=new Uint32Array(t),a=new e.InstancedBufferAttribute(i,1,!1);return a.setUsage(e.DynamicDrawUsage),o.setAttribute("splatIndex",a),o.instanceCount=t,o}static buildScenes(t,n){const r=[];r.length=t.length;for(let s=0;s<t.length;s++){const o=t[s],i=n[s]||{};let a=i.position||[0,0,0],c=i.rotation||[0,0,0,1],l=i.scale||[1,1,1];const h=(new e.Vector3).fromArray(a),d=(new e.Quaternion).fromArray(c),u=(new e.Vector3).fromArray(l);r[s]=K.createScene(o,h,d,u)}return r}static createScene(e,t,n,r){return new O(e,t,n,r)}static buildSplatIndexMaps(e){const t=[],n=[];let r=0;for(let s=0;s<e.length;s++){const o=e[s].getSplatCount();for(let e=0;e<o;e++)t[r]=e,n[r]=s,r++}return{localSplatIndexMap:t,sceneIndexMap:n}}static buildSplatTree(t,n=[]){const r=new H(8,1e3);console.time("SplatTree build");const s=new e.Vector4;r.processSplatMesh(t,(e=>{t.getSplatColor(e,s);const r=t.getSceneIndexForSplat(e),o=n[r]||1;return s.w>=o})),console.timeEnd("SplatTree build");let o=0,i=0,a=0,c=0;return r.visitLeaves((e=>{const t=e.data.indexes.length;t>0&&(i+=t,a=Math.max(a,t),c++,o++)})),console.log(`SplatTree leaves: ${r.countLeaves()}`),console.log(`SplatTree leaves with splats:${o}`),i/=c,console.log(`Avg splat count per node: ${i}`),console.log(`Total splat count: ${t.getSplatCount()}`),r}build(e,t,n=!0){this.disposeMeshData();const r=K.getTotalSplatCountForSplatBuffers(e),s=K.buildScenes(e,t);if(n)for(let e=0;e<this.scenes.length&&e<s.length;e++){const t=s[e],n=this.getScene(e);t.copyTransformData(n)}this.scenes=s,this.geometry=K.buildGeomtery(r),this.material=K.buildMaterial(this.dynamicMode);const o=K.buildSplatIndexMaps(e);this.globalSplatIndexToLocalSplatIndexMap=o.localSplatIndexMap,this.globalSplatIndexToSceneIndexMap=o.sceneIndexMap,this.splatTree=K.buildSplatTree(this,t.map((e=>e.splatAlphaRemovalThreshold||1))),this.enableDistancesComputationOnGPU&&this.setupDistancesComputationTransformFeedback(),this.resetDataFromSplatBuffers()}dispose(){this.disposeMeshData(),this.enableDistancesComputationOnGPU&&this.disposeDistancesComputationGPUResources()}disposeMeshData(){this.geometry&&this.geometry!==G&&(this.geometry.dispose(),this.geometry=null);for(let e in this.splatDataTextures)if(this.splatDataTextures.hasOwnProperty(e)){const t=this.splatDataTextures[e];t.texture&&(t.texture.dispose(),t.texture=null)}this.splatDataTextures=null,this.material&&(this.material.dispose(),this.material=null),this.splatTree=null}getSplatTree(){return this.splatTree}resetDataFromSplatBuffers(){this.uploadSplatDataToTextures(),this.enableDistancesComputationOnGPU&&(this.updateGPUCentersBufferForDistancesComputation(),this.updateGPUTransformIndexesBufferForDistancesComputation())}uploadSplatDataToTextures(){const t=this.getSplatCount(),n=new Float32Array(6*t),r=new Float32Array(3*t),s=new Uint8Array(4*t);this.fillSplatDataArrays(n,r,s);const o=new e.Vector2(4096,1024);for(;o.x*o.y*2<6*t;)o.y*=2;const i=new e.Vector2(4096,1024);for(;i.x*i.y*4<4*t;)i.y*=2;let a,c;if(this.halfPrecisionCovariancesOnGPU){c=new Uint16Array(o.x*o.y*2);for(let t=0;t<n.length;t++)c[t]=e.DataUtils.toHalfFloat(n[t]);a=new e.DataTexture(c,o.x,o.y,e.RGFormat,e.HalfFloatType)}else c=new Float32Array(o.x*o.y*2),c.set(n),a=new e.DataTexture(c,o.x,o.y,e.RGFormat,e.FloatType);a.needsUpdate=!0,this.material.uniforms.covariancesTexture.value=a,this.material.uniforms.covariancesTextureSize.value.copy(o);const l=new Uint32Array(i.x*i.y*4);for(let e=0;e<t;e++){const t=4*e,n=3*e,o=4*e;l[o]=(h=s[t],d=s[t+1],u=s[t+2],m=s[t+3],h+(d<<8)+(u<<16)+(m<<24)),l[o+1]=p(r[n]),l[o+2]=p(r[n+1]),l[o+3]=p(r[n+2])}var h,d,u,m;const f=new e.DataTexture(l,i.x,i.y,e.RGBAIntegerFormat,e.UnsignedIntType);if(f.internalFormat="RGBA32UI",f.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=f,this.material.uniforms.centersColorsTextureSize.value.copy(i),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={covariances:{data:c,texture:a,size:o},centerColors:{data:l,texture:f,size:i}},this.dynamicMode){const n=new e.Vector2(4096,1024);for(;n.x*n.y*1<t;)n.y*=2;const r=new Uint32Array(n.x*n.y*1);for(let e=0;e<t;e++)r[e]=this.globalSplatIndexToSceneIndexMap[e];const s=new e.DataTexture(r,n.x,n.y,e.RedIntegerFormat,e.UnsignedIntType);s.internalFormat="R32UI",s.needsUpdate=!0,this.material.uniforms.transformIndexesTexture.value=s,this.material.uniforms.transformIndexesTextureSize.value.copy(n),this.material.uniformsNeedUpdate=!0,this.splatDataTextures.tansformIndexes={data:r,texture:s,size:n}}}updateRenderIndexes(e,t){const n=this.geometry;n.attributes.splatIndex.set(e),n.attributes.splatIndex.needsUpdate=!0,n.instanceCount=t}updateTransforms(){for(let e=0;e<this.scenes.length;e++){this.getScene(e).updateTransform()}}updateUniforms=function(){const t=new e.Vector2;return function(e,n,r){if(this.getSplatCount()>0){if(t.set(e.x*this.devicePixelRatio,e.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(t),this.material.uniforms.basisViewport.value.set(1/t.x,1/t.y),this.material.uniforms.focal.value.set(n,r),this.dynamicMode)for(let e=0;e<this.scenes.length;e++)this.material.uniforms.transforms.value[e].copy(this.getScene(e).transform);this.material.uniformsNeedUpdate=!0}}}();getSplatDataTextures(){return this.splatDataTextures}getSplatCount(){return K.getTotalSplatCountForScenes(this.scenes)}static getTotalSplatCountForScenes(e){let t=0;for(let n of e)n&&n.splatBuffer&&(t+=n.splatBuffer.getSplatCount());return t}static getTotalSplatCountForSplatBuffers(e){let t=0;for(let n of e)t+=n.getSplatCount();return t}disposeDistancesComputationGPUResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.vao&&(e.deleteVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.vao=null),this.distancesTransformFeedback.program&&(e.deleteProgram(this.distancesTransformFeedback.program),e.deleteShader(this.distancesTransformFeedback.vertexShader),e.deleteShader(this.distancesTransformFeedback.fragmentShader),this.distancesTransformFeedback.program=null,this.distancesTransformFeedback.vertexShader=null,this.distancesTransformFeedback.fragmentShader=null),this.disposeDistancesComputationGPUBufferResources(),this.distancesTransformFeedback.id&&(e.deleteTransformFeedback(this.distancesTransformFeedback.id),this.distancesTransformFeedback.id=null)}disposeDistancesComputationGPUBufferResources(){if(!this.renderer)return;const e=this.renderer.getContext();this.distancesTransformFeedback.centersBuffer&&(this.distancesTransformFeedback.centersBuffer=null,e.deleteBuffer(this.distancesTransformFeedback.centersBuffer)),this.distancesTransformFeedback.outDistancesBuffer&&(e.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer),this.distancesTransformFeedback.outDistancesBuffer=null)}setRenderer(e){e!==this.renderer&&(this.renderer=e,this.enableDistancesComputationOnGPU&&this.getSplatCount()>0&&(this.setupDistancesComputationTransformFeedback(),this.updateGPUCentersBufferForDistancesComputation(),this.updateGPUTransformIndexesBufferForDistancesComputation()))}setupDistancesComputationTransformFeedback=function(){let e,t;return function(){const n=this.getSplatCount();if(!this.renderer||e===this.renderer&&t===n)return;const r=e!==this.renderer,s=t!==n;r?this.disposeDistancesComputationGPUResources():s&&this.disposeDistancesComputationGPUBufferResources();const o=this.renderer.getContext(),i=(e,t,n)=>{const r=e.createShader(t);if(!r)return console.error("Fatal error: gl could not create a shader object."),null;e.shaderSource(r,n),e.compileShader(r);if(!e.getShaderParameter(r,e.COMPILE_STATUS)){let n="unknown";t===e.VERTEX_SHADER?n="vertex shader":t===e.FRAGMENT_SHADER&&(n="fragement shader");const s=e.getShaderInfoLog(r);return console.error("Failed to compile "+n+" with these errors:"+s),e.deleteShader(r),null}return r};let a;this.integerBasedDistancesComputation?(a="#version 300 es\n                in ivec4 center;\n                flat out int distance;",this.dynamicMode?a+=`\n                        in uint transformIndex;\n                        uniform ivec4 transforms[${W.MaxScenes}];\n                        void main(void) {\n                            ivec4 transform = transforms[transformIndex];\n                            distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;\n                        }\n                    `:a+="\n                        uniform ivec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    "):(a="#version 300 es\n                in vec3 center;\n                flat out float distance;",this.dynamicMode?a+=`\n                        in uint transformIndex;\n                        uniform mat4 transforms[${W.MaxScenes}];\n                        void main(void) {\n                            vec4 transformedCenter = transforms[transformIndex] * vec4(center, 1.0);\n                            distance = transformedCenter.z;\n                        }\n                    `:a+="\n                        uniform vec3 modelViewProj;\n                        void main(void) {\n                            distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;\n                        }\n                    ");const c=o.getParameter(o.VERTEX_ARRAY_BINDING),l=o.getParameter(o.CURRENT_PROGRAM);if(r&&(this.distancesTransformFeedback.vao=o.createVertexArray()),o.bindVertexArray(this.distancesTransformFeedback.vao),r){const e=o.createProgram(),t=i(o,o.VERTEX_SHADER,a),n=i(o,o.FRAGMENT_SHADER,"#version 300 es\n                precision lowp float;\n                out vec4 fragColor;\n                void main(){}\n            ");if(!t||!n)throw new Error("Could not compile shaders for distances computation on GPU.");o.attachShader(e,t),o.attachShader(e,n),o.transformFeedbackVaryings(e,["distance"],o.SEPARATE_ATTRIBS),o.linkProgram(e);if(!o.getProgramParameter(e,o.LINK_STATUS)){const r=o.getProgramInfoLog(e);throw console.error("Fatal error: Failed to link program: "+r),o.deleteProgram(e),o.deleteShader(n),o.deleteShader(t),new Error("Could not link shaders for distances computation on GPU.")}this.distancesTransformFeedback.program=e,this.distancesTransformFeedback.vertexShader=t,this.distancesTransformFeedback.vertexShader=n}if(o.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.dynamicMode){this.distancesTransformFeedback.transformIndexesLoc=o.getAttribLocation(this.distancesTransformFeedback.program,"transformIndex");for(let e=0;e<this.scenes.length;e++)this.distancesTransformFeedback.transformsLocs[e]=o.getUniformLocation(this.distancesTransformFeedback.program,`transforms[${e}]`)}else this.distancesTransformFeedback.modelViewProjLoc=o.getUniformLocation(this.distancesTransformFeedback.program,"modelViewProj");(r||s)&&(this.distancesTransformFeedback.centersBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,o.INT,0,0):o.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,3,o.FLOAT,!1,0,0),this.dynamicMode&&(this.distancesTransformFeedback.transformIndexesBuffer=o.createBuffer(),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.transformIndexesBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc),o.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc,1,o.UNSIGNED_INT,0,0))),(r||s)&&(this.distancesTransformFeedback.outDistancesBuffer=o.createBuffer()),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),o.bufferData(o.ARRAY_BUFFER,4*n,o.STATIC_READ),r&&(this.distancesTransformFeedback.id=o.createTransformFeedback()),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),l&&o.useProgram(l),c&&o.bindVertexArray(c),e=this.renderer,t=n}}();updateGPUCentersBufferForDistancesComputation(){if(!this.renderer)return;const e=this.renderer.getContext(),t=e.getParameter(e.VERTEX_ARRAY_BINDING);if(e.bindVertexArray(this.distancesTransformFeedback.vao),e.bindBuffer(e.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),this.integerBasedDistancesComputation){const t=this.getIntegerCenters(!0);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}else{const t=this.getFloatCenters(!1);e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}e.bindBuffer(e.ARRAY_BUFFER,null),t&&e.bindVertexArray(t)}updateGPUTransformIndexesBufferForDistancesComputation(){if(!this.renderer||!this.dynamicMode)return;const e=this.renderer.getContext(),t=e.getParameter(e.VERTEX_ARRAY_BINDING);e.bindVertexArray(this.distancesTransformFeedback.vao),e.bindBuffer(e.ARRAY_BUFFER,this.distancesTransformFeedback.transformIndexesBuffer),e.bufferData(e.ARRAY_BUFFER,this.getTransformIndexes(),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),t&&e.bindVertexArray(t)}getTransformIndexes(){const e=new Uint32Array(this.globalSplatIndexToSceneIndexMap.length);return e.set(this.globalSplatIndexToSceneIndexMap),e}fillTransformsArray=function(){const e=[];return function(t){e.length!==t.length&&(e.length=t.length);for(let t=0;t<this.scenes.length;t++){const n=this.getScene(t).transform.elements;for(let r=0;r<16;r++)e[16*t+r]=n[r]}t.set(e)}}();computeDistancesOnGPU=function(){const t=new e.Matrix4;return function(e,n){if(!this.renderer)return;const r=this.renderer.getContext(),s=r.getParameter(r.VERTEX_ARRAY_BINDING),o=r.getParameter(r.CURRENT_PROGRAM);if(r.bindVertexArray(this.distancesTransformFeedback.vao),r.useProgram(this.distancesTransformFeedback.program),r.enable(r.RASTERIZER_DISCARD),this.dynamicMode)for(let n=0;n<this.scenes.length;n++)if(t.copy(this.getScene(n).transform),t.premultiply(e),this.integerBasedDistancesComputation){const e=K.getIntegerMatrixArray(t),s=[e[2],e[6],e[10],e[14]];r.uniform4i(this.distancesTransformFeedback.transformsLocs[n],s[0],s[1],s[2],s[3])}else r.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[n],!1,t.elements);else if(this.integerBasedDistancesComputation){const t=K.getIntegerMatrixArray(e),n=[t[2],t[6],t[10]];r.uniform3i(this.distancesTransformFeedback.modelViewProjLoc,n[0],n[1],n[2])}else{const t=[e.elements[2],e.elements[6],e.elements[10]];r.uniform3f(this.distancesTransformFeedback.modelViewProjLoc,t[0],t[1],t[2])}r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),this.integerBasedDistancesComputation?r.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,4,r.INT,0,0):r.vertexAttribPointer(this.distancesTransformFeedback.centersLoc,3,r.FLOAT,!1,0,0),this.dynamicMode&&(r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.transformIndexesBuffer),r.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc),r.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc,1,r.UNSIGNED_INT,0,0)),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),r.beginTransformFeedback(r.POINTS),r.drawArrays(r.POINTS,0,this.getSplatCount()),r.endTransformFeedback(),r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER,0,null),r.bindTransformFeedback(r.TRANSFORM_FEEDBACK,null),r.disable(r.RASTERIZER_DISCARD);const i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);r.flush();const a=new Promise((e=>{const t=()=>{switch(r.clientWaitSync(i,0,0)){case r.TIMEOUT_EXPIRED:return setTimeout(t);case r.WAIT_FAILED:throw new Error("should never get here");default:r.deleteSync(i);const s=r.getParameter(r.VERTEX_ARRAY_BINDING);r.bindVertexArray(this.distancesTransformFeedback.vao),r.bindBuffer(r.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),r.getBufferSubData(r.ARRAY_BUFFER,0,n),r.bindBuffer(r.ARRAY_BUFFER,null),s&&r.bindVertexArray(s),e()}};setTimeout(t)}));return o&&r.useProgram(o),s&&r.bindVertexArray(s),a}}();getLocalSplatParameters(e,t,n){null==n&&(n=!this.dynamicMode),t.splatBuffer=this.getSplatBufferForSplat(e),t.localIndex=this.getSplatLocalIndex(e),t.sceneTransform=n?this.getSceneTransformForSplat(e):null}fillSplatDataArrays(e,t,n,r){let s=0;for(let o=0;o<this.scenes.length;o++){null==r&&(r=!this.dynamicMode);const i=this.getScene(o),a=i.splatBuffer,c=r?i.transform:null;e&&a.fillSplatCovarianceArray(e,s,c),t&&a.fillSplatCenterArray(t,s,c),n&&a.fillSplatColorArray(n,s,c),s+=a.getSplatCount()}}getIntegerCenters(e){const t=this.getSplatCount(),n=new Float32Array(3*t);let r;this.fillSplatDataArrays(null,n,null);let s=e?4:3;r=new Int32Array(t*s);for(let o=0;o<t;o++){for(let e=0;e<3;e++)r[o*s+e]=Math.round(1e3*n[3*o+e]);e&&(r[o*s+3]=1e3)}return r}getFloatCenters(e){const t=this.getSplatCount(),n=new Float32Array(3*t);if(this.fillSplatDataArrays(null,n,null),!e)return n;let r=new Float32Array(4*t);for(let e=0;e<t;e++){for(let t=0;t<3;t++)r[4*e+t]=n[3*e+t];r[4*e+3]=1}return r}getSplatCenter=function(){const e={};return function(t,n,r){this.getLocalSplatParameters(t,e,r),e.splatBuffer.getSplatCenter(e.localIndex,n,e.sceneTransform)}}();getSplatScaleAndRotation=function(){const e={};return function(t,n,r,s){this.getLocalSplatParameters(t,e,s),e.splatBuffer.getSplatScaleAndRotation(e.localIndex,n,r,e.sceneTransform)}}();getSplatColor=function(){const e={};return function(t,n){this.getLocalSplatParameters(t,e),e.splatBuffer.getSplatColor(e.localIndex,n,e.sceneTransform)}}();getSceneTransform(e,t){const n=this.getScene(e);n.updateTransform(),t.copy(n.transform)}getScene(e){if(e<0||e>=this.scenes.length)throw new Error("SplatMesh::getScene() -> Invalid scene index.");return this.scenes[e]}getSplatBufferForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).splatBuffer}getSceneIndexForSplat(e){return this.globalSplatIndexToSceneIndexMap[e]}getSceneTransformForSplat(e){return this.getScene(this.globalSplatIndexToSceneIndexMap[e]).transform}getSplatLocalIndex(e){return this.globalSplatIndexToLocalSplatIndexMap[e]}static getIntegerMatrixArray(e){const t=e.elements,n=[];for(let e=0;e<16;e++)n[e]=Math.round(1e3*t[e]);return n}}function X(e){let t,n,r,s,o,i,a,c,l,h,d,u,p,m,f,g,y;e.onmessage=A=>{if(A.data.centers)centers=A.data.centers,transformIndexes=A.data.transformIndexes,s?new Int32Array(n,m,4*i).set(new Int32Array(centers)):new Float32Array(n,m,4*i).set(new Float32Array(centers)),o&&new Uint32Array(n,l,i).set(new Uint32Array(transformIndexes)),e.postMessage({sortSetupComplete:!0});else if(A.data.sort){const x=A.data.sort.splatRenderCount||0,C=A.data.sort.splatSortCount||0,w=A.data.sort.usePrecomputedDistances;let v,b,S;r||(v=A.data.sort.indexesToSort,S=A.data.sort.transforms,w&&(b=A.data.sort.precomputedDistances)),function(A,x,C,w,v,b,S){const M=performance.now();if(!r&&(new Uint32Array(n,a,v.byteLength/y.BytesPerInt).set(v),new Float32Array(n,h,S.byteLength/y.BytesPerFloat).set(S),w)){let e;e=s?new Int32Array(n,d,b.byteLength/y.BytesPerInt):new Float32Array(n,d,b.byteLength/y.BytesPerFloat),e.set(b)}g||(g=new Uint32Array(y.DepthMapRange)),new Float32Array(n,f,16).set(C),new Uint32Array(n,p,y.DepthMapRange).set(g),t.exports.sortIndexes(a,m,d,u,p,f,c,l,h,y.DepthMapRange,A,x,i,w,s,o);const I={sortDone:!0,splatSortCount:A,splatRenderCount:x,sortTime:0},P=[];if(!r){const e=new Uint32Array(n,c,x),t=new Uint32Array(x);t.set(e),I.sortedIndexes=t.buffer,P.push(t.buffer)}const T=performance.now();I.sortTime=T-M,e.postMessage(I,P)}(C,x,A.data.sort.modelViewProj,w,v,b,S)}else if(A.data.init){y=A.data.init.Constants,i=A.data.init.splatCount,r=A.data.init.useSharedMemory,s=A.data.init.integerBasedSort,o=A.data.init.dynamicMode;const g=s?4*y.BytesPerInt:4*y.BytesPerFloat,x=new Uint8Array(A.data.init.sorterWasmBytes),C=16*y.BytesPerFloat,w=i*y.BytesPerInt,v=i*g,b=C,S=s?i*y.BytesPerInt:i*y.BytesPerFloat,M=i*y.BytesPerInt,I=i*y.BytesPerInt,P=y.DepthMapRange*y.BytesPerInt*2,T=o?i*y.BytesPerInt:0,D=o?y.MaxScenes*C:0,B=32*y.MemoryPageSize,F=w+v+b+S+M+P+I+T+D+B,E=Math.floor(F/y.MemoryPageSize)+1,R={module:{},env:{memory:new WebAssembly.Memory({initial:2*E,maximum:4*E,shared:!0})}};WebAssembly.compile(x).then((e=>WebAssembly.instantiate(e,R))).then((s=>{t=s,a=0,m=a+w,f=m+v,d=f+b,u=d+S,p=u+M,c=p+P,l=c+I,h=l+T,n=R.env.memory.buffer,r?e.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:n,indexesToSortOffset:a,sortedIndexesBuffer:n,sortedIndexesOffset:c,precomputedDistancesBuffer:n,precomputedDistancesOffset:d,transformsBuffer:n,transformsOffset:h}):e.postMessage({sortSetupPhase1Complete:!0})}))}}}function q(e,t,n,r){const s=new Worker(URL.createObjectURL(new Blob(["(",X.toString(),")(self)"],{type:"application/javascript"}))),o=atob("AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEbA2AAAGAQf39/f39/f39/f39/f39/fwBgAAF/AhIBA2VudgZtZW1vcnkCAwCAgAQDBAMAAQIHOQMRX193YXNtX2NhbGxfY3RvcnMAAAtzb3J0SW5kZXhlcwABE2Vtc2NyaXB0ZW5fdGxzX2luaXQAAgrHEAMDAAELuxAFAXwDewJ/A30CfiALIAprIQwCQCAOBEAgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQIgDCEBA0AgAyABQQJ0IgVqIAIgACAFaigCAEECdGooAgAiBTYCACAFIA4gBSAOSBshDiAFIA0gBSANShshDSABQQFqIgEgC0cNAAsMAgsgDwRAQfj///8HIQ5BiICAgHghDSALIAxNDQJBfyEPIAwhAgNAIA8gByAAIAJBAnQiFGooAgAiFUECdGooAgAiCkcEQAJ+IAX9CQIIIAggCkEGdGoiD/0JAgAgDyoCEP0gASAPKgIg/SACIA8qAjD9IAP95gEgBf0JAhggD/0JAgQgDyoCFP0gASAPKgIk/SACIA8qAjT9IAP95gH95AEgBf0JAiggD/0JAgggDyoCGP0gASAPKgIo/SACIA8qAjj9IAP95gH95AEgBf0JAjggD/0JAgwgDyoCHP0gASAPKgIs/SACIA8qAjz9IAP95gH95AEiEf0fArv9FCAR/R8Du/0iAf0MAAAAAABAj0AAAAAAAECPQCIS/fIBIhP9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGQJ+IBP9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiETAn4gEf0fALv9FCAR/R8Bu/0iASAS/fIBIhH9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGiATIBn9HgEhEgJ+IBH9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiAa/R4BIBL9DQABAgMICQoLEBESExgZGhshEiAKIQ8LIAMgFGogASAVQQR0av0AAAAgEv21ASIR/RsAIBH9GwFqIBH9GwJqIBH9GwNqIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAILAn8gBSoCGLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEKAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyECAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQ5BiICAgHghDSALIAxNDQEgAv0RIAr9HAEgBf0cAiESIAwhBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmoiAjYCACACIA4gAiAOSBshDiACIA0gAiANShshDSAFQQFqIgUgC0cNAAsMAQsgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQEgDCEBA0AgAyABQQJ0IgVqAn8gAiAAIAVqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAFBAWoiASALRw0ACwwBCwJAIA9FBEAgCyAMSw0BQYiAgIB4IQ1B+P///wchDgwCC0H4////ByEOQYiAgIB4IQ0gCyAMTQ0BQX8hDyAMIQIDQCAPIAcgACACQQJ0IhRqKAIAQQJ0IhVqKAIAIgpHBEAgBf0JAgggCCAKQQZ0aiIP/QkCACAPKgIQ/SABIA8qAiD9IAIgDyoCMP0gA/3mASAF/QkCGCAP/QkCBCAPKgIU/SABIA8qAiT9IAIgDyoCNP0gA/3mAf3kASAF/QkCKCAP/QkCCCAPKgIY/SABIA8qAij9IAIgDyoCOP0gA/3mAf3kASAF/QkCOCAP/QkCDCAPKgIc/SABIA8qAiz9IAIgDyoCPP0gA/3mAf3kASERIAohDwsgAyAUagJ/IBEgASAVQQJ0IgpqKQIA/RL95gEiEv0fACAS/R8BkiARIBH9DQgJCgsMDQ4PAAAAAAAAAAAgASAKQQhyaikCAP0S/eYBIhL9HwCSIBL9HwGSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAELIAUqAighFiAFKgIYIRcgBSoCCCEYQfj///8HIQ5BiICAgHghDSAMIQUDQAJ/IBggASAAIAVBAnQiB2ooAgBBBHRqIgIqAgCUIBcgAioCBJSSIBYgAioCCJSSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIQogAyAHaiAKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAVBAWoiBSALRw0ACwsgCyAMSwRAIAlBAWuzIA2yIA6yk5UhFiAMIQ0DQAJ/IBYgAyANQQJ0aiIBKAIAIA5rspQiF4tDAAAAT10EQCAXqAwBC0GAgICAeAshCiABIAo2AgAgBCAKQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhDgNAIAQgDkECdGoiASABKAIAIA1qIg02AgAgDkEBaiIOIAlHDQALCyAMQQBKBEAgDCEOA0AgBiAOQQFrIgFBAnQiAmogACACaigCADYCACAOQQFKIQIgASEOIAINAAsLIAsgDEoEQCALIQ4DQCAGIAsgBCADIA5BAWsiDkECdCIBaigCAEECdGoiAigCACIFa0ECdGogACABaigCADYCACACIAVBAWs2AgAgDCAOSA0ACwsLBABBAAs="),i=new Uint8Array(o.length);for(let e=0;e<o.length;e++)i[e]=o.charCodeAt(e);return s.postMessage({init:{sorterWasmBytes:i.buffer,splatCount:e,useSharedMemory:t,integerBasedSort:n,dynamicMode:r,Constants:{BytesPerFloat:W.BytesPerFloat,BytesPerInt:W.BytesPerInt,DepthMapRange:W.DepthMapRange,MemoryPageSize:W.MemoryPageSize,MaxScenes:W.MaxScenes}}}),s}const J={None:0,VR:1,AR:2};class Z{static createButton(e){const t=document.createElement("button");function n(){t.style.display="",t.style.cursor="auto",t.style.left="calc(50% - 75px)",t.style.width="150px",t.onmouseenter=null,t.onmouseleave=null,t.onclick=null}function r(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return t.id="VRButton",t.style.display="none",r(t),navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){let n=null;async function r(r){r.addEventListener("end",s),await e.xr.setSession(r),t.textContent="EXIT VR",n=r}function s(){n.removeEventListener("end",s),t.textContent="ENTER VR",n=null}t.style.display="",t.style.cursor="pointer",t.style.left="calc(50% - 50px)",t.style.width="100px",t.textContent="ENTER VR";const o={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]};t.onmouseenter=function(){t.style.opacity="1.0"},t.onmouseleave=function(){t.style.opacity="0.5"},t.onclick=function(){null===n?navigator.xr.requestSession("immersive-vr",o).then(r):(n.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",o).then(r).catch((e=>{console.warn(e)})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-vr",o).then(r).catch((e=>{console.warn(e)}))}():(n(),t.textContent="VR NOT SUPPORTED"),r&&Z.xrSessionIsGranted&&t.click()})).catch((function(e){n(),console.warn("Exception when trying to call xr.isSessionSupported",e),t.textContent="VR NOT ALLOWED"})),t;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",r(e),e}}static registerSessionGrantedListener(){if("undefined"!=typeof navigator&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{Z.xrSessionIsGranted=!0}))}}}Z.xrSessionIsGranted=!1,Z.registerSessionGrantedListener();class ${static createButton(e,t={}){const n=document.createElement("button");function r(){n.style.display="",n.style.cursor="auto",n.style.left="calc(50% - 75px)",n.style.width="150px",n.onmouseenter=null,n.onmouseleave=null,n.onclick=null}function s(e){e.style.position="absolute",e.style.bottom="20px",e.style.padding="12px 6px",e.style.border="1px solid #fff",e.style.borderRadius="4px",e.style.background="rgba(0,0,0,0.1)",e.style.color="#fff",e.style.font="normal 13px sans-serif",e.style.textAlign="center",e.style.opacity="0.5",e.style.outline="none",e.style.zIndex="999"}if("xr"in navigator)return n.id="ARButton",n.style.display="none",s(n),navigator.xr.isSessionSupported("immersive-ar").then((function(s){s?function(){if(void 0===t.domOverlay){const e=document.createElement("div");e.style.display="none",document.body.appendChild(e);const n=document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttribute("width",38),n.setAttribute("height",38),n.style.position="absolute",n.style.right="20px",n.style.top="20px",n.addEventListener("click",(function(){r.end()})),e.appendChild(n);const s=document.createElementNS("http://www.w3.org/2000/svg","path");s.setAttribute("d","M 12,12 L 28,28 M 28,12 12,28"),s.setAttribute("stroke","#fff"),s.setAttribute("stroke-width",2),n.appendChild(s),void 0===t.optionalFeatures&&(t.optionalFeatures=[]),t.optionalFeatures.push("dom-overlay"),t.domOverlay={root:e}}let r=null;async function s(s){s.addEventListener("end",o),e.xr.setReferenceSpaceType("local"),await e.xr.setSession(s),n.textContent="STOP AR",t.domOverlay.root.style.display="",r=s}function o(){r.removeEventListener("end",o),n.textContent="START AR",t.domOverlay.root.style.display="none",r=null}n.style.display="",n.style.cursor="pointer",n.style.left="calc(50% - 50px)",n.style.width="100px",n.textContent="START AR",n.onmouseenter=function(){n.style.opacity="1.0"},n.onmouseleave=function(){n.style.opacity="0.5"},n.onclick=function(){null===r?navigator.xr.requestSession("immersive-ar",t).then(s):(r.end(),void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(s).catch((e=>{console.warn(e)})))},void 0!==navigator.xr.offerSession&&navigator.xr.offerSession("immersive-ar",t).then(s).catch((e=>{console.warn(e)}))}():(r(),n.textContent="AR NOT SUPPORTED")})).catch((function(e){r(),console.warn("Exception when trying to call xr.isSessionSupported",e),n.textContent="AR NOT ALLOWED"})),n;{const e=document.createElement("a");return!1===window.isSecureContext?(e.href=document.location.href.replace(/^http:/,"https:"),e.innerHTML="WEBXR NEEDS HTTPS"):(e.href="https://immersiveweb.dev/",e.innerHTML="WEBXR NOT AVAILABLE"),e.style.left="calc(50% - 90px)",e.style.width="180px",e.style.textDecoration="none",s(e),e}}}class ee{constructor(t={}){t.cameraUp||(t.cameraUp=[0,1,0]),this.cameraUp=(new e.Vector3).fromArray(t.cameraUp),t.initialCameraPosition||(t.initialCameraPosition=[0,10,15]),this.initialCameraPosition=(new e.Vector3).fromArray(t.initialCameraPosition),t.initialCameraLookAt||(t.initialCameraLookAt=[0,0,0]),this.initialCameraLookAt=(new e.Vector3).fromArray(t.initialCameraLookAt),this.dropInMode=t.dropInMode||!1,void 0!==t.selfDrivenMode&&null!==t.selfDrivenMode||(t.selfDrivenMode=!0),this.selfDrivenMode=t.selfDrivenMode&&!this.dropInMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),void 0===t.useBuiltInControls&&(t.useBuiltInControls=!0),this.useBuiltInControls=t.useBuiltInControls,this.rootElement=t.rootElement,this.ignoreDevicePixelRatio=t.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio,void 0!==t.halfPrecisionCovariancesOnGPU&&null!==t.halfPrecisionCovariancesOnGPU||(t.halfPrecisionCovariancesOnGPU=!0),this.halfPrecisionCovariancesOnGPU=t.halfPrecisionCovariancesOnGPU,this.threeScene=t.threeScene,this.renderer=t.renderer,this.camera=t.camera,this.gpuAcceleratedSort=t.gpuAcceleratedSort,!0!==this.gpuAcceleratedSort&&!1!==this.gpuAcceleratedSort&&(this.isMobile()?this.gpuAcceleratedSort=!1:this.gpuAcceleratedSort=!0),void 0!==t.integerBasedSort&&null!==t.integerBasedSort||(t.integerBasedSort=!0),this.integerBasedSort=t.integerBasedSort,void 0!==t.sharedMemoryForWorkers&&null!==t.sharedMemoryForWorkers||(t.sharedMemoryForWorkers=!0),this.sharedMemoryForWorkers=t.sharedMemoryForWorkers;const n=!!t.dynamicScene;this.splatMesh=new K(n,this.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort,this.integerBasedSort),this.webXRMode=t.webXRMode||J.None,this.controls=null,this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.sortWorkerTransforms=null,this.selfDrivenModeRunning=!1,this.splatRenderingInitialized=!1,this.raycaster=new U,this.infoPanel=null,this.infoPanelCells={},this.currentFPS=0,this.lastSortTime=0,this.previousCameraTarget=new e.Vector3,this.nextCameraTarget=new e.Vector3,this.mousePosition=new e.Vector2,this.mouseDownPosition=new e.Vector2,this.mouseDownTime=null,this.resizeObserver=null,this.mouseMoveListener=null,this.mouseDownListener=null,this.mouseUpListener=null,this.keyDownListener=null,this.sortPromise=null,this.sortPromiseResolver=null,this.loadingSpinner=new F(null,this.rootElement||document.body),this.loadingSpinner.hide(),this.usingExternalCamera=!(!this.dropInMode&&!this.camera),this.usingExternalRenderer=!(!this.dropInMode&&!this.renderer),this.initialized=!1,this.dropInMode||this.init()}init(){if(this.initialized)return;this.rootElement||(this.usingExternalRenderer?this.rootElement=this.renderer.domElement.parentElement||document.body:(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",this.rootElement.style.position="absolute",document.body.appendChild(this.rootElement)));const t=new e.Vector2;this.getRenderDimensions(t),this.usingExternalCamera||(this.camera=new e.PerspectiveCamera(50,t.x/t.y,.1,500),this.camera.position.copy(this.initialCameraPosition),this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)),this.usingExternalRenderer||(this.renderer=new e.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new e.Color(0),0),this.renderer.setSize(t.x,t.y),this.resizeObserver=new ResizeObserver((()=>{this.getRenderDimensions(t),this.renderer.setSize(t.x,t.y)})),this.resizeObserver.observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)),this.webXRMode&&(this.webXRMode===J.VR?this.rootElement.appendChild(Z.createButton(this.renderer)):this.webXRMode===J.AR&&this.rootElement.appendChild($.createButton(this.renderer)),this.renderer.xr.enabled=!0,this.camera.up.copy(this.cameraUp).normalize(),this.camera.lookAt(this.initialCameraLookAt)),this.threeScene=this.threeScene||new e.Scene,this.sceneHelper=new R(this.threeScene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.useBuiltInControls&&this.webXRMode===J.None&&(this.controls=new B(this.camera,this.renderer.domElement),this.controls.listenToKeyEvents(window),this.controls.rotateSpeed=.5,this.controls.maxPolarAngle=.75*Math.PI,this.controls.minPolarAngle=.1,this.controls.enableDamping=!0,this.controls.dampingFactor=.05,this.controls.target.copy(this.initialCameraLookAt),this.mouseMoveListener=this.onMouseMove.bind(this),this.rootElement.addEventListener("pointermove",this.mouseMoveListener,!1),this.mouseDownListener=this.onMouseDown.bind(this),this.rootElement.addEventListener("pointerdown",this.mouseDownListener,!1),this.mouseUpListener=this.onMouseUp.bind(this),this.rootElement.addEventListener("pointerup",this.mouseUpListener,!1),this.keyDownListener=this.onKeyDown.bind(this),window.addEventListener("keydown",this.keyDownListener,!1)),this.setupInfoPanel(),this.loadingSpinner.setContainer(this.rootElement),this.initialized=!0}removeEventHandlers(){this.useBuiltInControls&&(this.rootElement.removeEventListener("pointermove",this.mouseMoveListener),this.mouseMoveListener=null,this.rootElement.removeEventListener("pointerdown",this.mouseDownListener),this.mouseDownListener=null,this.rootElement.removeEventListener("pointerup",this.mouseUpListener),this.mouseUpListener=null,window.removeEventListener("keydown",this.keyDownListener),this.keyDownListener=null)}onKeyDown=function(){const t=new e.Vector3,n=new e.Matrix4,r=new e.Matrix4;return function(e){switch(t.set(0,0,-1),t.transformDirection(this.camera.matrixWorld),n.makeRotationAxis(t,Math.PI/128),r.makeRotationAxis(t,-Math.PI/128),e.code){case"ArrowLeft":this.camera.up.transformDirection(n);break;case"ArrowRight":this.camera.up.transformDirection(r);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyP":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.style.display="block":this.infoPanel.style.display="none"}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=g()}onMouseUp=function(){const t=new e.Vector2;return function(e){t.copy(this.mousePosition).sub(this.mouseDownPosition);g()-this.mouseDownTime<.5&&t.length()<2&&this.onMouseClick(e)}}();onMouseClick(e){this.mousePosition.set(e.offsetX,e.offsetY),this.checkForFocalPointChange()}checkForFocalPointChange=function(){const t=new e.Vector2,n=new e.Vector3,r=[];return function(){if(!this.transitioningCameraTarget&&(this.getRenderDimensions(t),r.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,t),this.raycaster.intersectSplatMesh(this.splatMesh,r),r.length>0)){const e=r[0].origin;n.copy(e).sub(this.camera.position),n.length()>.75&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(e),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=g())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setupInfoPanel(){this.infoPanel=document.createElement("div"),this.infoPanel.style.position="absolute",this.infoPanel.style.padding="10px",this.infoPanel.style.backgroundColor="#cccccc",this.infoPanel.style.border="#aaaaaa 1px solid",this.infoPanel.style.zIndex=100,this.infoPanel.style.width="375px",this.infoPanel.style.fontFamily="arial",this.infoPanel.style.fontSize="10pt",this.infoPanel.style.textAlign="left";const e=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Cursor position","cursorPosition"],["FPS","fps"],["Render window","renderWindow"],["Rendering:","renderSplatCount"],["Sort time","sortTime"]],t=document.createElement("div");t.style.display="table";for(let n of e){const e=document.createElement("div");e.style.display="table-row";const r=document.createElement("div");r.style.display="table-cell",r.style.width="110px",r.innerHTML=`${n[0]}: `;const s=document.createElement("div");s.style.display="table-cell",s.style.width="10px",s.innerHTML=" ";const o=document.createElement("div");o.style.display="table-cell",o.innerHTML="",this.infoPanelCells[n[1]]=o,e.appendChild(r),e.appendChild(s),e.appendChild(o),t.appendChild(e)}this.infoPanel.appendChild(t),this.infoPanel.style.display="none",this.renderer.domElement.parentElement.prepend(this.infoPanel)}updateSplatMesh=function(){const t=new e.Vector2;return function(){if(!this.splatMesh)return;this.splatMesh.getSplatCount()>0&&(this.splatMesh.updateTransforms(),this.getRenderDimensions(t),this.cameraFocalLengthX=this.camera.projectionMatrix.elements[0]*this.devicePixelRatio*t.x*.45,this.cameraFocalLengthY=this.camera.projectionMatrix.elements[5]*this.devicePixelRatio*t.y*.45,this.splatMesh.updateUniforms(t,this.cameraFocalLengthX,this.cameraFocalLengthY))}}();addSplatScene(e,t={}){!1!==t.showLoadingSpinner&&(t.showLoadingSpinner=!0),t.showLoadingSpinner&&this.loadingSpinner.show();const n=this.loadFileToSplatBuffer(e,t.splatAlphaRemovalThreshold,((e,n)=>{if(t.showLoadingSpinner)if(100==e)this.loadingSpinner.setMessage("Download complete!");else{const e=n?`: ${n}`:"...";this.loadingSpinner.setMessage(`Downloading${e}`)}t.onProgress&&t.onProgress(e,n,"downloading")}),t.format);return new u(((r,s)=>{n.then((e=>{t.showLoadingSpinner&&this.loadingSpinner.hide(),t.onProgress&&t.onProgress(0,"0%","processing");const n={rotation:t.rotation||t.orientation,position:t.position,scale:t.scale,splatAlphaRemovalThreshold:t.splatAlphaRemovalThreshold};this.addSplatBuffers([e],[n],t.showLoadingSpinner).then((()=>{t.onProgress&&t.onProgress(100,"100%","processing"),r()}))})).catch((()=>{t.showLoadingSpinner&&this.loadingSpinner.hide(),s(new Error(`Viewer::addSplatScene -> Could not load file ${e}`))}))}),n.abortHandler)}addSplatScenes(e,t=!0,n=void 0){const r=e.length,s=[];t&&this.loadingSpinner.show();const o=(e,o,i)=>{s[e]=o;let a=0;for(let e=0;e<r;e++)a+=s[e]||0;a/=r,i=`${a.toFixed(2)}%`,t&&(100==a?this.loadingSpinner.setMessage("Download complete!"):this.loadingSpinner.setMessage(`Downloading: ${i}`)),n&&n(a,i,"downloading")},i=[],a=[];for(let t=0;t<e.length;t++){const n=this.loadFileToSplatBuffer(e[t].path,e[t].splatAlphaRemovalThreshold,o.bind(this,t),e.format);a.push(n.abortHandler),i.push(n.promise)}return new u(((r,s)=>{Promise.all(i).then((s=>{t&&this.loadingSpinner.hide(),n&&options.onProgress(0,"0%","processing"),this.addSplatBuffers(s,e,t).then((()=>{n&&n(100,"100%","processing"),r()}))})).catch((()=>{t&&this.loadingSpinner.hide(),s(new Error("Viewer::addSplatScenes -> Could not load one or more splat scenes."))}))}),(()=>{for(let e of a)e()}))}loadFileToSplatBuffer(e,t=1,n=void 0,r=void 0){const s=(e,t)=>{n&&n(e,t,"downloading")};if(null!=r){if(r===v.Splat||r===v.KSplat)return(new b).loadFromURL(e,s,0,t,void 0,void 0,r);if(r===v.Ply)return(new w).loadFromURL(e,s,0,t)}else{if(b.isFileSplatFormat(e))return(new b).loadFromURL(e,s,0,t);if(e.endsWith(".ply"))return(new w).loadFromURL(e,s,0,t)}return u.reject(new Error(`Viewer::loadFileToSplatBuffer -> File format not supported: ${e}`))}addSplatBuffers=function(){let e,t=0;return function(n,r=[],s=!0){this.splatRenderingInitialized=!1,t++;const o=()=>new Promise((e=>{s&&(this.loadingSpinner.show(),this.loadingSpinner.setMessage("Processing splats...")),window.setTimeout((()=>{this.disposeSortWorker(),this.addSplatBuffersToMesh(n,r),this.setupSortWorker(this.splatMesh).then((()=>{t--,0===t&&(s&&this.loadingSpinner.hide(),this.splatRenderingInitialized=!0),e()}))}),1)}));return e=e?e.then((()=>o())):o(),e}}();disposeSortWorker(){this.sortWorker&&this.sortWorker.terminate(),this.sortWorker=null,this.sortRunning=!1}addSplatBuffersToMesh(e,t){const n=this.splatMesh.splatBuffers||[],r=this.splatMesh.splatBufferOptions||[];n.push(...e),r.push(...t),this.splatMesh.build(n,r,!0),this.renderer&&this.splatMesh.setRenderer(this.renderer),this.splatMesh.frustumCulled=!1}setupSortWorker(e){return new Promise((t=>{const n=this.integerBasedSort?Int32Array:Float32Array,r=e.getSplatCount(),s=q(r,this.sharedMemoryForWorkers,this.integerBasedSort,this.splatMesh.dynamicMode);s.onmessage=e=>{if(e.data.sortDone){if(this.sortRunning=!1,this.sharedMemoryForWorkers)this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes,e.data.splatRenderCount);else{const t=new Uint32Array(e.data.sortedIndexes,0,e.data.splatRenderCount);this.splatMesh.updateRenderIndexes(t,e.data.splatRenderCount)}this.lastSortTime=e.data.sortTime,this.sortPromiseResolver(),this.sortPromise=null,this.sortPromiseResolver=null}else if(e.data.sortCanceled)this.sortRunning=!1;else if(e.data.sortSetupPhase1Complete){console.log("Sorting web worker WASM setup complete.");const t=this.integerBasedSort?this.splatMesh.getIntegerCenters(!0):this.splatMesh.getFloatCenters(!0),o=this.splatMesh.getTransformIndexes();s.postMessage({centers:t.buffer,transformIndexes:o.buffer}),this.sharedMemoryForWorkers?(this.sortWorkerSortedIndexes=new Uint32Array(e.data.sortedIndexesBuffer,e.data.sortedIndexesOffset,r),this.sortWorkerIndexesToSort=new Uint32Array(e.data.indexesToSortBuffer,e.data.indexesToSortOffset,r),this.sortWorkerPrecomputedDistances=new n(e.data.precomputedDistancesBuffer,e.data.precomputedDistancesOffset,r),this.sortWorkerTransforms=new Float32Array(e.data.transformsBuffer,e.data.transformsOffset,16*W.MaxScenes)):(this.sortWorkerIndexesToSort=new Uint32Array(r),this.sortWorkerPrecomputedDistances=new n(r),this.sortWorkerTransforms=new Float32Array(16*W.MaxScenes));for(let e=0;e<r;e++)this.sortWorkerIndexesToSort[e]=e}else if(e.data.sortSetupComplete){console.log("Sorting web worker ready.");const e=this.splatMesh.getSplatDataTextures(),n=e.covariances.size,r=e.centerColors.size;console.log("Covariances texture size: "+n.x+" x "+n.y),console.log("Centers/colors texture size: "+r.x+" x "+r.y),this.sortWorker=s,t()}}}))}start(){if(!this.selfDrivenMode)throw new Error("Cannot start viewer unless it is in self driven mode.");this.webXRMode?this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc):this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(this.webXRMode||cancelAnimationFrame(this.requestFrameId),this.selfDrivenModeRunning=!1)}async dispose(){this.sortPromise&&await this.sortPromise,this.stop(),this.controls&&(this.controls.dispose(),this.controls=null),this.splatMesh&&(this.splatMesh.dispose(),this.splatMesh=null),this.sceneHelper&&(this.sceneHelper.dispose(),this.sceneHelper=null),this.resizeObserver&&(this.resizeObserver.unobserve(this.rootElement),this.resizeObserver=null),this.renderer&&(this.usingExternalRenderer||this.renderer.dispose(),this.renderer=null),this.disposeSortWorker(),this.removeEventHandlers(),this.camera=null,this.threeScene=null,this.splatRenderingInitialized=!1,this.initialized=!1}selfDrivenUpdate(){this.selfDrivenMode&&!this.webXRMode&&(this.requestFrameId=requestAnimationFrame(this.selfDrivenUpdateFunc)),this.update(),this.render()}render=function(){if(!this.initialized||!this.splatRenderingInitialized)return;const e=this.renderer.autoClear;this.renderer.autoClear=!1,(e=>{for(let t of e.children)if(t.visible)return!0;return!1})(this.threeScene)&&this.renderer.render(this.threeScene,this.camera),this.renderer.render(this.splatMesh,this.camera),this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=e};update(e,t){this.dropInMode&&this.updateForDropInMode(e,t),this.initialized&&this.splatRenderingInitialized&&(this.controls&&this.controls.update(),this.updateSplatSort(),this.updateForRendererSizeChanges(),this.updateSplatMesh(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfoPanel(),this.updateControlPlane())}updateForDropInMode(e,t){this.renderer=e,this.splatMesh&&this.splatMesh.setRenderer(this.renderer),this.camera=t,this.controls&&(this.controls.object=t),this.init()}updateFPS=function(){let e=g(),t=0;return function(){const n=g();n-e>=1?(this.currentFPS=t,t=0,e=n):t++}}();updateForRendererSizeChanges=function(){const t=new e.Vector2,n=new e.Vector2;return function(){this.renderer.getSize(n),n.x===t.x&&n.y===t.y||(this.usingExternalCamera||(this.camera.aspect=n.x/n.y,this.camera.updateProjectionMatrix()),t.copy(n))}}();timingSensitiveUpdates=function(){let e;return function(){const t=g();e||(e=t);const n=t-e;this.updateCameraTransition(t),this.updateFocusMarker(n),e=t}}();updateCameraTransition=function(){let t=new e.Vector3,n=new e.Vector3,r=new e.Vector3;return function(e){if(this.transitioningCameraTarget){n.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),r.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const s=Math.acos(n.dot(r)),o=(s/(Math.PI/3)*.65+.3)/s*(e-this.transitioningCameraTargetStartTime);t.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,o),this.camera.lookAt(t),this.controls.target.copy(t),o>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const t=new e.Vector2;let n=!1;return function(e){this.getRenderDimensions(t);if(this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const r=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let s=Math.min(r+10*e,1);this.sceneHelper.setFocusMarkerOpacity(s),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,t),n=!0}else{let r;if(r=n?1:Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),r>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,t);let n=Math.max(r-2.5*e,0);this.sceneHelper.setFocusMarkerOpacity(n),0===n&&this.sceneHelper.setFocusMarkerVisibility(!1)}n=!1}}}();updateMeshCursor=function(){const t=[],n=new e.Vector2;return function(){this.showMeshCursor?(this.getRenderDimensions(n),t.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,n),this.raycaster.intersectSplatMesh(this.splatMesh,t),t.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(t[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):this.sceneHelper.setMeshCursorVisibility(!1)}}();updateInfoPanel=function(){const t=new e.Vector2;return function(){if(!this.showInfo)return;const e=this.splatMesh.getSplatCount();this.getRenderDimensions(t);const n=this.camera.position,r=`[${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}]`;if(this.infoPanelCells.cameraPosition.innerHTML=r,this.controls){const e=this.controls.target,t=`[${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}]`;this.infoPanelCells.cameraLookAt.innerHTML=t}const s=this.camera.up,o=`[${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}]`;if(this.infoPanelCells.cameraUp.innerHTML=o,this.showMeshCursor){const e=this.sceneHelper.meshCursor.position,t=`[${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}]`;this.infoPanelCells.cursorPosition.innerHTML=t}else this.infoPanelCells.cursorPosition.innerHTML="N/A";this.infoPanelCells.fps.innerHTML=this.currentFPS,this.infoPanelCells.renderWindow.innerHTML=`${t.x} x ${t.y}`;const i=this.splatRenderCount/e*100;this.infoPanelCells.renderSplatCount.innerHTML=`${this.splatRenderCount} splats out of ${e} (${i.toFixed(2)}%)`,this.infoPanelCells.sortTime.innerHTML=`${this.lastSortTime.toFixed(3)} ms`}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}updateSplatSort=function(){const t=new e.Matrix4,n=[],r=new e.Vector3(0,0,-1),s=new e.Vector3(0,0,-1),o=new e.Vector3,i=new e.Vector3,a=[];let c=0;const l=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return async function(e=!1,h=!1){if(this.sortRunning)return;if(!this.initialized||!this.splatRenderingInitialized)return;let d=0,u=0,p=!1,m=!1;if(s.set(0,0,-1).applyQuaternion(this.camera.quaternion),d=s.dot(r),u=i.copy(this.camera.position).sub(o).length(),!e&&!this.splatMesh.dynamicMode&&0===a.length&&c>0&&(d<=.95&&(p=!0),u>=1&&(m=!0),!p&&!m))return;if(this.sortRunning=!0,this.splatRenderCount=this.gatherSceneNodesForSort(h),this.sortPromise=new Promise((e=>{this.sortPromiseResolver=e})),t.copy(this.camera.matrixWorld).invert(),t.premultiply(this.camera.projectionMatrix),t.multiply(this.splatMesh.matrixWorld),this.gpuAcceleratedSort&&(a.length<=1||a.length%2==0)&&await this.splatMesh.computeDistancesOnGPU(t,this.sortWorkerPrecomputedDistances),this.splatMesh.dynamicMode)a.push(this.splatRenderCount);else if(0===a.length){for(let e of l)if(d<e.angleThreshold){for(let t of e.sortFractions)a.push(Math.floor(this.splatRenderCount*t));break}a.push(this.splatRenderCount)}const f=Math.min(a.shift(),this.splatRenderCount);n[0]=this.camera.position.x,n[1]=this.camera.position.y,n[2]=this.camera.position.z;const g={modelViewProj:t.elements,cameraPosition:n,splatRenderCount:this.splatRenderCount,splatSortCount:f,usePrecomputedDistances:this.gpuAcceleratedSort};this.splatMesh.dynamicMode&&this.splatMesh.fillTransformsArray(this.sortWorkerTransforms),this.sharedMemoryForWorkers||(g.indexesToSort=this.sortWorkerIndexesToSort,g.transforms=this.sortWorkerTransforms,this.gpuAcceleratedSort&&(g.precomputedDistances=this.sortWorkerPrecomputedDistances)),this.sortWorker.postMessage({sort:g}),0===a.length&&(o.copy(this.camera.position),r.copy(s)),c++}}();gatherSceneNodesForSort=function(){const t=[],n=new e.Vector3,r=new e.Vector3,s=new e.Vector3,o=new e.Matrix4,i=new e.Matrix4,a=new e.Matrix4,c=new e.Vector3,l=new e.Vector3(0,0,-1),h=new e.Vector3,d=e=>h.copy(e.max).sub(e.min).length();return function(h){this.getRenderDimensions(c);const u=c.y/2/Math.tan(this.camera.fov/2*e.MathUtils.DEG2RAD),p=Math.atan(c.x/2/u),m=Math.atan(c.y/2/u),f=Math.cos(p),g=Math.cos(m),y=this.splatMesh.getSplatTree();i.copy(this.camera.matrixWorld).invert(),i.multiply(this.splatMesh.matrixWorld);let A=0,x=0;for(let e=0;e<y.subTrees.length;e++){const c=y.subTrees[e];o.copy(i),this.splatMesh.dynamicMode&&(this.splatMesh.getSceneTransform(e,a),o.multiply(a));const u=c.nodesWithIndexes.length;for(let e=0;e<u;e++){const i=c.nodesWithIndexes[e];s.copy(i.center).applyMatrix4(o);const a=s.length();s.normalize(),n.copy(s).setX(0).normalize(),r.copy(s).setY(0).normalize();const u=l.dot(r),p=l.dot(n),m=d(i);!h&&(u<f-.6||p<g-.6||a>125)&&a>m||(x+=i.data.indexes.length,t[A]=i,i.data.distanceToNode=a,A++)}}t.length=A,t.sort(((e,t)=>e.data.distanceToNode<t.data.distanceToNode?-1:1));let C=x*W.BytesPerInt;for(let e=0;e<A;e++){const n=t[e],r=n.data.indexes.length,s=r*W.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,C-s,r).set(n.data.indexes),C-=s}return x}}();getSplatMesh(){return this.splatMesh}getSplatScene(e){return this.splatMesh.getScene(e)}isMobile(){return navigator.userAgent.includes("Mobi")}}class te extends e.Group{constructor(e={}){super(),e.selfDrivenMode=!1,e.useBuiltInControls=!1,e.rootElement=null,e.ignoreDevicePixelRatio=!1,e.dropInMode=!0,e.camera=void 0,e.renderer=void 0,this.viewer=new ee(e),this.callbackMesh=te.createCallbackMesh(),this.add(this.callbackMesh),this.callbackMesh.onBeforeRender=te.onBeforeRender.bind(this,this.viewer)}addSplatScene(e,t={}){!1!==t.showLoadingSpinner&&(t.showLoadingSpinner=!0);const n=this.viewer.addSplatScene(e,t);return n.then((()=>{this.add(this.viewer.splatMesh)})),n}addSplatScenes(e,t){!1!==t&&(t=!0);const n=this.viewer.addSplatScenes(e,t);return n.then((()=>{this.add(this.viewer.splatMesh)})),n}getSplatScene(e){return this.viewer.getSplatScene(e)}dispose(){return this.viewer.dispose()}static onBeforeRender(e,t,n,r){e.update(t,r)}static createCallbackMesh(){const t=new e.SphereGeometry(1,8,8),n=new e.MeshBasicMaterial;n.colorWrite=!1,n.depthWrite=!1;const r=new e.Mesh(t,n);return r.frustumCulled=!1,r}}export{u as AbortablePromise,te as DropInViewer,B as OrbitControls,w as PlyLoader,C as PlyParser,v as SceneFormat,d as SplatBuffer,x as SplatCompressor,b as SplatLoader,ee as Viewer,J as WebXRMode};
//# sourceMappingURL=gaussian-splats-3d.module.min.js.map
